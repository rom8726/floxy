// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package floxy

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStepHandler creates a new instance of MockStepHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStepHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStepHandler {
	mock := &MockStepHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStepHandler is an autogenerated mock type for the StepHandler type
type MockStepHandler struct {
	mock.Mock
}

type MockStepHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStepHandler) EXPECT() *MockStepHandler_Expecter {
	return &MockStepHandler_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockStepHandler
func (_mock *MockStepHandler) Execute(ctx context.Context, stepCtx StepContext, input json.RawMessage) (json.RawMessage, error) {
	ret := _mock.Called(ctx, stepCtx, input)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 json.RawMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, StepContext, json.RawMessage) (json.RawMessage, error)); ok {
		return returnFunc(ctx, stepCtx, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, StepContext, json.RawMessage) json.RawMessage); ok {
		r0 = returnFunc(ctx, stepCtx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, StepContext, json.RawMessage) error); ok {
		r1 = returnFunc(ctx, stepCtx, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStepHandler_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockStepHandler_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - stepCtx StepContext
//   - input json.RawMessage
func (_e *MockStepHandler_Expecter) Execute(ctx interface{}, stepCtx interface{}, input interface{}) *MockStepHandler_Execute_Call {
	return &MockStepHandler_Execute_Call{Call: _e.mock.On("Execute", ctx, stepCtx, input)}
}

func (_c *MockStepHandler_Execute_Call) Run(run func(ctx context.Context, stepCtx StepContext, input json.RawMessage)) *MockStepHandler_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 StepContext
		if args[1] != nil {
			arg1 = args[1].(StepContext)
		}
		var arg2 json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStepHandler_Execute_Call) Return(rawMessage json.RawMessage, err error) *MockStepHandler_Execute_Call {
	_c.Call.Return(rawMessage, err)
	return _c
}

func (_c *MockStepHandler_Execute_Call) RunAndReturn(run func(ctx context.Context, stepCtx StepContext, input json.RawMessage) (json.RawMessage, error)) *MockStepHandler_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockStepHandler
func (_mock *MockStepHandler) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockStepHandler_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockStepHandler_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockStepHandler_Expecter) Name() *MockStepHandler_Name_Call {
	return &MockStepHandler_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockStepHandler_Name_Call) Run(run func()) *MockStepHandler_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepHandler_Name_Call) Return(s string) *MockStepHandler_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockStepHandler_Name_Call) RunAndReturn(run func() string) *MockStepHandler_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStepContext creates a new instance of MockStepContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStepContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStepContext {
	mock := &MockStepContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStepContext is an autogenerated mock type for the StepContext type
type MockStepContext struct {
	mock.Mock
}

type MockStepContext_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStepContext) EXPECT() *MockStepContext_Expecter {
	return &MockStepContext_Expecter{mock: &_m.Mock}
}

// GetVariable provides a mock function for the type MockStepContext
func (_mock *MockStepContext) GetVariable(key string) (string, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetVariable")
	}

	var r0 string
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (string, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockStepContext_GetVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVariable'
type MockStepContext_GetVariable_Call struct {
	*mock.Call
}

// GetVariable is a helper method to define mock.On call
//   - key string
func (_e *MockStepContext_Expecter) GetVariable(key interface{}) *MockStepContext_GetVariable_Call {
	return &MockStepContext_GetVariable_Call{Call: _e.mock.On("GetVariable", key)}
}

func (_c *MockStepContext_GetVariable_Call) Run(run func(key string)) *MockStepContext_GetVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStepContext_GetVariable_Call) Return(s string, b bool) *MockStepContext_GetVariable_Call {
	_c.Call.Return(s, b)
	return _c
}

func (_c *MockStepContext_GetVariable_Call) RunAndReturn(run func(key string) (string, bool)) *MockStepContext_GetVariable_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceID provides a mock function for the type MockStepContext
func (_mock *MockStepContext) InstanceID() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for InstanceID")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// MockStepContext_InstanceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceID'
type MockStepContext_InstanceID_Call struct {
	*mock.Call
}

// InstanceID is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) InstanceID() *MockStepContext_InstanceID_Call {
	return &MockStepContext_InstanceID_Call{Call: _e.mock.On("InstanceID")}
}

func (_c *MockStepContext_InstanceID_Call) Run(run func()) *MockStepContext_InstanceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_InstanceID_Call) Return(n int64) *MockStepContext_InstanceID_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockStepContext_InstanceID_Call) RunAndReturn(run func() int64) *MockStepContext_InstanceID_Call {
	_c.Call.Return(run)
	return _c
}

// RetryCount provides a mock function for the type MockStepContext
func (_mock *MockStepContext) RetryCount() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RetryCount")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockStepContext_RetryCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryCount'
type MockStepContext_RetryCount_Call struct {
	*mock.Call
}

// RetryCount is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) RetryCount() *MockStepContext_RetryCount_Call {
	return &MockStepContext_RetryCount_Call{Call: _e.mock.On("RetryCount")}
}

func (_c *MockStepContext_RetryCount_Call) Run(run func()) *MockStepContext_RetryCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_RetryCount_Call) Return(n int) *MockStepContext_RetryCount_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockStepContext_RetryCount_Call) RunAndReturn(run func() int) *MockStepContext_RetryCount_Call {
	_c.Call.Return(run)
	return _c
}

// StepName provides a mock function for the type MockStepContext
func (_mock *MockStepContext) StepName() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StepName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockStepContext_StepName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepName'
type MockStepContext_StepName_Call struct {
	*mock.Call
}

// StepName is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) StepName() *MockStepContext_StepName_Call {
	return &MockStepContext_StepName_Call{Call: _e.mock.On("StepName")}
}

func (_c *MockStepContext_StepName_Call) Run(run func()) *MockStepContext_StepName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_StepName_Call) Return(s string) *MockStepContext_StepName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockStepContext_StepName_Call) RunAndReturn(run func() string) *MockStepContext_StepName_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// CreateInstance provides a mock function for the type MockStore
func (_mock *MockStore) CreateInstance(ctx context.Context, workflowID string, input json.RawMessage) (*WorkflowInstance, error) {
	ret := _mock.Called(ctx, workflowID, input)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstance")
	}

	var r0 *WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, json.RawMessage) (*WorkflowInstance, error)); ok {
		return returnFunc(ctx, workflowID, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, json.RawMessage) *WorkflowInstance); ok {
		r0 = returnFunc(ctx, workflowID, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, json.RawMessage) error); ok {
		r1 = returnFunc(ctx, workflowID, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CreateInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInstance'
type MockStore_CreateInstance_Call struct {
	*mock.Call
}

// CreateInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowID string
//   - input json.RawMessage
func (_e *MockStore_Expecter) CreateInstance(ctx interface{}, workflowID interface{}, input interface{}) *MockStore_CreateInstance_Call {
	return &MockStore_CreateInstance_Call{Call: _e.mock.On("CreateInstance", ctx, workflowID, input)}
}

func (_c *MockStore_CreateInstance_Call) Run(run func(ctx context.Context, workflowID string, input json.RawMessage)) *MockStore_CreateInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_CreateInstance_Call) Return(workflowInstance *WorkflowInstance, err error) *MockStore_CreateInstance_Call {
	_c.Call.Return(workflowInstance, err)
	return _c
}

func (_c *MockStore_CreateInstance_Call) RunAndReturn(run func(ctx context.Context, workflowID string, input json.RawMessage) (*WorkflowInstance, error)) *MockStore_CreateInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJoinState provides a mock function for the type MockStore
func (_mock *MockStore) CreateJoinState(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy) error {
	ret := _mock.Called(ctx, instanceID, joinStepName, waitingFor, strategy)

	if len(ret) == 0 {
		panic("no return value specified for CreateJoinState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, []string, JoinStrategy) error); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, waitingFor, strategy)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJoinState'
type MockStore_CreateJoinState_Call struct {
	*mock.Call
}

// CreateJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - waitingFor []string
//   - strategy JoinStrategy
func (_e *MockStore_Expecter) CreateJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}, waitingFor interface{}, strategy interface{}) *MockStore_CreateJoinState_Call {
	return &MockStore_CreateJoinState_Call{Call: _e.mock.On("CreateJoinState", ctx, instanceID, joinStepName, waitingFor, strategy)}
}

func (_c *MockStore_CreateJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy)) *MockStore_CreateJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []string
		if args[3] != nil {
			arg3 = args[3].([]string)
		}
		var arg4 JoinStrategy
		if args[4] != nil {
			arg4 = args[4].(JoinStrategy)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_CreateJoinState_Call) Return(err error) *MockStore_CreateJoinState_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy) error) *MockStore_CreateJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStep provides a mock function for the type MockStore
func (_mock *MockStore) CreateStep(ctx context.Context, step *WorkflowStep) error {
	ret := _mock.Called(ctx, step)

	if len(ret) == 0 {
		panic("no return value specified for CreateStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowStep) error); ok {
		r0 = returnFunc(ctx, step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStep'
type MockStore_CreateStep_Call struct {
	*mock.Call
}

// CreateStep is a helper method to define mock.On call
//   - ctx context.Context
//   - step *WorkflowStep
func (_e *MockStore_Expecter) CreateStep(ctx interface{}, step interface{}) *MockStore_CreateStep_Call {
	return &MockStore_CreateStep_Call{Call: _e.mock.On("CreateStep", ctx, step)}
}

func (_c *MockStore_CreateStep_Call) Run(run func(ctx context.Context, step *WorkflowStep)) *MockStore_CreateStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowStep
		if args[1] != nil {
			arg1 = args[1].(*WorkflowStep)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateStep_Call) Return(err error) *MockStore_CreateStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateStep_Call) RunAndReturn(run func(ctx context.Context, step *WorkflowStep) error) *MockStore_CreateStep_Call {
	_c.Call.Return(run)
	return _c
}

// DequeueStep provides a mock function for the type MockStore
func (_mock *MockStore) DequeueStep(ctx context.Context, workerID string) (*QueueItem, error) {
	ret := _mock.Called(ctx, workerID)

	if len(ret) == 0 {
		panic("no return value specified for DequeueStep")
	}

	var r0 *QueueItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*QueueItem, error)); ok {
		return returnFunc(ctx, workerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *QueueItem); ok {
		r0 = returnFunc(ctx, workerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*QueueItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, workerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DequeueStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DequeueStep'
type MockStore_DequeueStep_Call struct {
	*mock.Call
}

// DequeueStep is a helper method to define mock.On call
//   - ctx context.Context
//   - workerID string
func (_e *MockStore_Expecter) DequeueStep(ctx interface{}, workerID interface{}) *MockStore_DequeueStep_Call {
	return &MockStore_DequeueStep_Call{Call: _e.mock.On("DequeueStep", ctx, workerID)}
}

func (_c *MockStore_DequeueStep_Call) Run(run func(ctx context.Context, workerID string)) *MockStore_DequeueStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_DequeueStep_Call) Return(queueItem *QueueItem, err error) *MockStore_DequeueStep_Call {
	_c.Call.Return(queueItem, err)
	return _c
}

func (_c *MockStore_DequeueStep_Call) RunAndReturn(run func(ctx context.Context, workerID string) (*QueueItem, error)) *MockStore_DequeueStep_Call {
	_c.Call.Return(run)
	return _c
}

// EnqueueStep provides a mock function for the type MockStore
func (_mock *MockStore) EnqueueStep(ctx context.Context, instanceID int64, stepID *int64, priority int, delay time.Duration) error {
	ret := _mock.Called(ctx, instanceID, stepID, priority, delay)

	if len(ret) == 0 {
		panic("no return value specified for EnqueueStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *int64, int, time.Duration) error); ok {
		r0 = returnFunc(ctx, instanceID, stepID, priority, delay)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_EnqueueStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnqueueStep'
type MockStore_EnqueueStep_Call struct {
	*mock.Call
}

// EnqueueStep is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - stepID *int64
//   - priority int
//   - delay time.Duration
func (_e *MockStore_Expecter) EnqueueStep(ctx interface{}, instanceID interface{}, stepID interface{}, priority interface{}, delay interface{}) *MockStore_EnqueueStep_Call {
	return &MockStore_EnqueueStep_Call{Call: _e.mock.On("EnqueueStep", ctx, instanceID, stepID, priority, delay)}
}

func (_c *MockStore_EnqueueStep_Call) Run(run func(ctx context.Context, instanceID int64, stepID *int64, priority int, delay time.Duration)) *MockStore_EnqueueStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *int64
		if args[2] != nil {
			arg2 = args[2].(*int64)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 time.Duration
		if args[4] != nil {
			arg4 = args[4].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_EnqueueStep_Call) Return(err error) *MockStore_EnqueueStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_EnqueueStep_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, stepID *int64, priority int, delay time.Duration) error) *MockStore_EnqueueStep_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstance provides a mock function for the type MockStore
func (_mock *MockStore) GetInstance(ctx context.Context, instanceID int64) (*WorkflowInstance, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetInstance")
	}

	var r0 *WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*WorkflowInstance, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *WorkflowInstance); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstance'
type MockStore_GetInstance_Call struct {
	*mock.Call
}

// GetInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetInstance(ctx interface{}, instanceID interface{}) *MockStore_GetInstance_Call {
	return &MockStore_GetInstance_Call{Call: _e.mock.On("GetInstance", ctx, instanceID)}
}

func (_c *MockStore_GetInstance_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetInstance_Call) Return(workflowInstance *WorkflowInstance, err error) *MockStore_GetInstance_Call {
	_c.Call.Return(workflowInstance, err)
	return _c
}

func (_c *MockStore_GetInstance_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) (*WorkflowInstance, error)) *MockStore_GetInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetJoinState provides a mock function for the type MockStore
func (_mock *MockStore) GetJoinState(ctx context.Context, instanceID int64, joinStepName string) (*JoinState, error) {
	ret := _mock.Called(ctx, instanceID, joinStepName)

	if len(ret) == 0 {
		panic("no return value specified for GetJoinState")
	}

	var r0 *JoinState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (*JoinState, error)); ok {
		return returnFunc(ctx, instanceID, joinStepName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) *JoinState); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JoinState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, instanceID, joinStepName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJoinState'
type MockStore_GetJoinState_Call struct {
	*mock.Call
}

// GetJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
func (_e *MockStore_Expecter) GetJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}) *MockStore_GetJoinState_Call {
	return &MockStore_GetJoinState_Call{Call: _e.mock.On("GetJoinState", ctx, instanceID, joinStepName)}
}

func (_c *MockStore_GetJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string)) *MockStore_GetJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_GetJoinState_Call) Return(joinState *JoinState, err error) *MockStore_GetJoinState_Call {
	_c.Call.Return(joinState, err)
	return _c
}

func (_c *MockStore_GetJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string) (*JoinState, error)) *MockStore_GetJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// GetStepsByInstance provides a mock function for the type MockStore
func (_mock *MockStore) GetStepsByInstance(ctx context.Context, instanceID int64) ([]*WorkflowStep, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetStepsByInstance")
	}

	var r0 []*WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]*WorkflowStep, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []*WorkflowStep); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetStepsByInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStepsByInstance'
type MockStore_GetStepsByInstance_Call struct {
	*mock.Call
}

// GetStepsByInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetStepsByInstance(ctx interface{}, instanceID interface{}) *MockStore_GetStepsByInstance_Call {
	return &MockStore_GetStepsByInstance_Call{Call: _e.mock.On("GetStepsByInstance", ctx, instanceID)}
}

func (_c *MockStore_GetStepsByInstance_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetStepsByInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetStepsByInstance_Call) Return(workflowSteps []*WorkflowStep, err error) *MockStore_GetStepsByInstance_Call {
	_c.Call.Return(workflowSteps, err)
	return _c
}

func (_c *MockStore_GetStepsByInstance_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) ([]*WorkflowStep, error)) *MockStore_GetStepsByInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowDefinition provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowDefinition(ctx context.Context, id string) (*WorkflowDefinition, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowDefinition")
	}

	var r0 *WorkflowDefinition
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*WorkflowDefinition, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *WorkflowDefinition); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowDefinition)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowDefinition'
type MockStore_GetWorkflowDefinition_Call struct {
	*mock.Call
}

// GetWorkflowDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetWorkflowDefinition(ctx interface{}, id interface{}) *MockStore_GetWorkflowDefinition_Call {
	return &MockStore_GetWorkflowDefinition_Call{Call: _e.mock.On("GetWorkflowDefinition", ctx, id)}
}

func (_c *MockStore_GetWorkflowDefinition_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowDefinition_Call) Return(workflowDefinition *WorkflowDefinition, err error) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Return(workflowDefinition, err)
	return _c
}

func (_c *MockStore_GetWorkflowDefinition_Call) RunAndReturn(run func(ctx context.Context, id string) (*WorkflowDefinition, error)) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// LogEvent provides a mock function for the type MockStore
func (_mock *MockStore) LogEvent(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any) error {
	ret := _mock.Called(ctx, instanceID, stepID, eventType, payload)

	if len(ret) == 0 {
		panic("no return value specified for LogEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *int64, string, any) error); ok {
		r0 = returnFunc(ctx, instanceID, stepID, eventType, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_LogEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogEvent'
type MockStore_LogEvent_Call struct {
	*mock.Call
}

// LogEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - stepID *int64
//   - eventType string
//   - payload any
func (_e *MockStore_Expecter) LogEvent(ctx interface{}, instanceID interface{}, stepID interface{}, eventType interface{}, payload interface{}) *MockStore_LogEvent_Call {
	return &MockStore_LogEvent_Call{Call: _e.mock.On("LogEvent", ctx, instanceID, stepID, eventType, payload)}
}

func (_c *MockStore_LogEvent_Call) Run(run func(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any)) *MockStore_LogEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *int64
		if args[2] != nil {
			arg2 = args[2].(*int64)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 any
		if args[4] != nil {
			arg4 = args[4].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_LogEvent_Call) Return(err error) *MockStore_LogEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_LogEvent_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any) error) *MockStore_LogEvent_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFromQueue provides a mock function for the type MockStore
func (_mock *MockStore) RemoveFromQueue(ctx context.Context, queueID int64) error {
	ret := _mock.Called(ctx, queueID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFromQueue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, queueID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RemoveFromQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFromQueue'
type MockStore_RemoveFromQueue_Call struct {
	*mock.Call
}

// RemoveFromQueue is a helper method to define mock.On call
//   - ctx context.Context
//   - queueID int64
func (_e *MockStore_Expecter) RemoveFromQueue(ctx interface{}, queueID interface{}) *MockStore_RemoveFromQueue_Call {
	return &MockStore_RemoveFromQueue_Call{Call: _e.mock.On("RemoveFromQueue", ctx, queueID)}
}

func (_c *MockStore_RemoveFromQueue_Call) Run(run func(ctx context.Context, queueID int64)) *MockStore_RemoveFromQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_RemoveFromQueue_Call) Return(err error) *MockStore_RemoveFromQueue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RemoveFromQueue_Call) RunAndReturn(run func(ctx context.Context, queueID int64) error) *MockStore_RemoveFromQueue_Call {
	_c.Call.Return(run)
	return _c
}

// SaveWorkflowDefinition provides a mock function for the type MockStore
func (_mock *MockStore) SaveWorkflowDefinition(ctx context.Context, def *WorkflowDefinition) error {
	ret := _mock.Called(ctx, def)

	if len(ret) == 0 {
		panic("no return value specified for SaveWorkflowDefinition")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowDefinition) error); ok {
		r0 = returnFunc(ctx, def)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SaveWorkflowDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveWorkflowDefinition'
type MockStore_SaveWorkflowDefinition_Call struct {
	*mock.Call
}

// SaveWorkflowDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - def *WorkflowDefinition
func (_e *MockStore_Expecter) SaveWorkflowDefinition(ctx interface{}, def interface{}) *MockStore_SaveWorkflowDefinition_Call {
	return &MockStore_SaveWorkflowDefinition_Call{Call: _e.mock.On("SaveWorkflowDefinition", ctx, def)}
}

func (_c *MockStore_SaveWorkflowDefinition_Call) Run(run func(ctx context.Context, def *WorkflowDefinition)) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowDefinition
		if args[1] != nil {
			arg1 = args[1].(*WorkflowDefinition)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_SaveWorkflowDefinition_Call) Return(err error) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SaveWorkflowDefinition_Call) RunAndReturn(run func(ctx context.Context, def *WorkflowDefinition) error) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInstanceStatus provides a mock function for the type MockStore
func (_mock *MockStore) UpdateInstanceStatus(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string) error {
	ret := _mock.Called(ctx, instanceID, status, output, errMsg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInstanceStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, WorkflowStatus, json.RawMessage, *string) error); ok {
		r0 = returnFunc(ctx, instanceID, status, output, errMsg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateInstanceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInstanceStatus'
type MockStore_UpdateInstanceStatus_Call struct {
	*mock.Call
}

// UpdateInstanceStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - status WorkflowStatus
//   - output json.RawMessage
//   - errMsg *string
func (_e *MockStore_Expecter) UpdateInstanceStatus(ctx interface{}, instanceID interface{}, status interface{}, output interface{}, errMsg interface{}) *MockStore_UpdateInstanceStatus_Call {
	return &MockStore_UpdateInstanceStatus_Call{Call: _e.mock.On("UpdateInstanceStatus", ctx, instanceID, status, output, errMsg)}
}

func (_c *MockStore_UpdateInstanceStatus_Call) Run(run func(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string)) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 WorkflowStatus
		if args[2] != nil {
			arg2 = args[2].(WorkflowStatus)
		}
		var arg3 json.RawMessage
		if args[3] != nil {
			arg3 = args[3].(json.RawMessage)
		}
		var arg4 *string
		if args[4] != nil {
			arg4 = args[4].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateInstanceStatus_Call) Return(err error) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateInstanceStatus_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string) error) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJoinState provides a mock function for the type MockStore
func (_mock *MockStore) UpdateJoinState(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool) (bool, error) {
	ret := _mock.Called(ctx, instanceID, joinStepName, completedStep, success)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJoinState")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, bool) (bool, error)); ok {
		return returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, bool) bool); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, bool) error); ok {
		r1 = returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_UpdateJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJoinState'
type MockStore_UpdateJoinState_Call struct {
	*mock.Call
}

// UpdateJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - completedStep string
//   - success bool
func (_e *MockStore_Expecter) UpdateJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}, completedStep interface{}, success interface{}) *MockStore_UpdateJoinState_Call {
	return &MockStore_UpdateJoinState_Call{Call: _e.mock.On("UpdateJoinState", ctx, instanceID, joinStepName, completedStep, success)}
}

func (_c *MockStore_UpdateJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool)) *MockStore_UpdateJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateJoinState_Call) Return(b bool, err error) *MockStore_UpdateJoinState_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_UpdateJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool) (bool, error)) *MockStore_UpdateJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStep provides a mock function for the type MockStore
func (_mock *MockStore) UpdateStep(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string) error {
	ret := _mock.Called(ctx, stepID, status, output, errMsg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, StepStatus, json.RawMessage, *string) error); ok {
		r0 = returnFunc(ctx, stepID, status, output, errMsg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStep'
type MockStore_UpdateStep_Call struct {
	*mock.Call
}

// UpdateStep is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - status StepStatus
//   - output json.RawMessage
//   - errMsg *string
func (_e *MockStore_Expecter) UpdateStep(ctx interface{}, stepID interface{}, status interface{}, output interface{}, errMsg interface{}) *MockStore_UpdateStep_Call {
	return &MockStore_UpdateStep_Call{Call: _e.mock.On("UpdateStep", ctx, stepID, status, output, errMsg)}
}

func (_c *MockStore_UpdateStep_Call) Run(run func(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string)) *MockStore_UpdateStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 StepStatus
		if args[2] != nil {
			arg2 = args[2].(StepStatus)
		}
		var arg3 json.RawMessage
		if args[3] != nil {
			arg3 = args[3].(json.RawMessage)
		}
		var arg4 *string
		if args[4] != nil {
			arg4 = args[4].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateStep_Call) Return(err error) *MockStore_UpdateStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateStep_Call) RunAndReturn(run func(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string) error) *MockStore_UpdateStep_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStepCompensationRetry provides a mock function for the type MockStore
func (_mock *MockStore) UpdateStepCompensationRetry(ctx context.Context, stepID int64, retryCount int, status StepStatus) error {
	ret := _mock.Called(ctx, stepID, retryCount, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStepCompensationRetry")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int, StepStatus) error); ok {
		r0 = returnFunc(ctx, stepID, retryCount, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateStepCompensationRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStepCompensationRetry'
type MockStore_UpdateStepCompensationRetry_Call struct {
	*mock.Call
}

// UpdateStepCompensationRetry is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - retryCount int
//   - status StepStatus
func (_e *MockStore_Expecter) UpdateStepCompensationRetry(ctx interface{}, stepID interface{}, retryCount interface{}, status interface{}) *MockStore_UpdateStepCompensationRetry_Call {
	return &MockStore_UpdateStepCompensationRetry_Call{Call: _e.mock.On("UpdateStepCompensationRetry", ctx, stepID, retryCount, status)}
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) Run(run func(ctx context.Context, stepID int64, retryCount int, status StepStatus)) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 StepStatus
		if args[3] != nil {
			arg3 = args[3].(StepStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) Return(err error) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) RunAndReturn(run func(ctx context.Context, stepID int64, retryCount int, status StepStatus) error) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTx creates a new instance of MockTx. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTx(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTx {
	mock := &MockTx{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTx is an autogenerated mock type for the Tx type
type MockTx struct {
	mock.Mock
}

type MockTx_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTx) EXPECT() *MockTx_Expecter {
	return &MockTx_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockTx
func (_mock *MockTx) Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 pgconn.CommandTag
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (pgconn.CommandTag, error)); ok {
		return returnFunc(ctx, sql, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgconn.CommandTag); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		r0 = ret.Get(0).(pgconn.CommandTag)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, sql, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTx_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockTx_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) Exec(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_Exec_Call {
	return &MockTx_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_Exec_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_Exec_Call) Return(commandTag pgconn.CommandTag, err error) *MockTx_Exec_Call {
	_c.Call.Return(commandTag, err)
	return _c
}

func (_c *MockTx_Exec_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error)) *MockTx_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function for the type MockTx
func (_mock *MockTx) Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 pgx.Rows
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (pgx.Rows, error)); ok {
		return returnFunc(ctx, sql, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgx.Rows); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Rows)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, sql, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTx_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type MockTx_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) Query(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_Query_Call {
	return &MockTx_Query_Call{Call: _e.mock.On("Query",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_Query_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_Query_Call) Return(rows pgx.Rows, err error) *MockTx_Query_Call {
	_c.Call.Return(rows, err)
	return _c
}

func (_c *MockTx_Query_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) (pgx.Rows, error)) *MockTx_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRow provides a mock function for the type MockTx
func (_mock *MockTx) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for QueryRow")
	}

	var r0 pgx.Row
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgx.Row); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Row)
		}
	}
	return r0
}

// MockTx_QueryRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRow'
type MockTx_QueryRow_Call struct {
	*mock.Call
}

// QueryRow is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) QueryRow(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_QueryRow_Call {
	return &MockTx_QueryRow_Call{Call: _e.mock.On("QueryRow",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_QueryRow_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_QueryRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_QueryRow_Call) Return(row pgx.Row) *MockTx_QueryRow_Call {
	_c.Call.Return(row)
	return _c
}

func (_c *MockTx_QueryRow_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) pgx.Row) *MockTx_QueryRow_Call {
	_c.Call.Return(run)
	return _c
}

// SendBatch provides a mock function for the type MockTx
func (_mock *MockTx) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for SendBatch")
	}

	var r0 pgx.BatchResults
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pgx.Batch) pgx.BatchResults); ok {
		r0 = returnFunc(ctx, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.BatchResults)
		}
	}
	return r0
}

// MockTx_SendBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendBatch'
type MockTx_SendBatch_Call struct {
	*mock.Call
}

// SendBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - b *pgx.Batch
func (_e *MockTx_Expecter) SendBatch(ctx interface{}, b interface{}) *MockTx_SendBatch_Call {
	return &MockTx_SendBatch_Call{Call: _e.mock.On("SendBatch", ctx, b)}
}

func (_c *MockTx_SendBatch_Call) Run(run func(ctx context.Context, b *pgx.Batch)) *MockTx_SendBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pgx.Batch
		if args[1] != nil {
			arg1 = args[1].(*pgx.Batch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTx_SendBatch_Call) Return(batchResults pgx.BatchResults) *MockTx_SendBatch_Call {
	_c.Call.Return(batchResults)
	return _c
}

func (_c *MockTx_SendBatch_Call) RunAndReturn(run func(ctx context.Context, b *pgx.Batch) pgx.BatchResults) *MockTx_SendBatch_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTxManager creates a new instance of MockTxManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTxManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTxManager {
	mock := &MockTxManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTxManager is an autogenerated mock type for the TxManager type
type MockTxManager struct {
	mock.Mock
}

type MockTxManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTxManager) EXPECT() *MockTxManager_Expecter {
	return &MockTxManager_Expecter{mock: &_m.Mock}
}

// ReadCommitted provides a mock function for the type MockTxManager
func (_mock *MockTxManager) ReadCommitted(ctx context.Context, fn func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for ReadCommitted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTxManager_ReadCommitted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadCommitted'
type MockTxManager_ReadCommitted_Call struct {
	*mock.Call
}

// ReadCommitted is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context) error
func (_e *MockTxManager_Expecter) ReadCommitted(ctx interface{}, fn interface{}) *MockTxManager_ReadCommitted_Call {
	return &MockTxManager_ReadCommitted_Call{Call: _e.mock.On("ReadCommitted", ctx, fn)}
}

func (_c *MockTxManager_ReadCommitted_Call) Run(run func(ctx context.Context, fn func(ctx context.Context) error)) *MockTxManager_ReadCommitted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTxManager_ReadCommitted_Call) Return(err error) *MockTxManager_ReadCommitted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTxManager_ReadCommitted_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context) error) error) *MockTxManager_ReadCommitted_Call {
	_c.Call.Return(run)
	return _c
}

// RepeatableRead provides a mock function for the type MockTxManager
func (_mock *MockTxManager) RepeatableRead(ctx context.Context, fn func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for RepeatableRead")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTxManager_RepeatableRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepeatableRead'
type MockTxManager_RepeatableRead_Call struct {
	*mock.Call
}

// RepeatableRead is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context) error
func (_e *MockTxManager_Expecter) RepeatableRead(ctx interface{}, fn interface{}) *MockTxManager_RepeatableRead_Call {
	return &MockTxManager_RepeatableRead_Call{Call: _e.mock.On("RepeatableRead", ctx, fn)}
}

func (_c *MockTxManager_RepeatableRead_Call) Run(run func(ctx context.Context, fn func(ctx context.Context) error)) *MockTxManager_RepeatableRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTxManager_RepeatableRead_Call) Return(err error) *MockTxManager_RepeatableRead_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTxManager_RepeatableRead_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context) error) error) *MockTxManager_RepeatableRead_Call {
	_c.Call.Return(run)
	return _c
}
