// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package floxy

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	mock "github.com/stretchr/testify/mock"
)

// NewMockIEngine creates a new instance of MockIEngine. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIEngine(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIEngine {
	mock := &MockIEngine{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIEngine is an autogenerated mock type for the IEngine type
type MockIEngine struct {
	mock.Mock
}

type MockIEngine_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIEngine) EXPECT() *MockIEngine_Expecter {
	return &MockIEngine_Expecter{mock: &_m.Mock}
}

// AbortWorkflow provides a mock function for the type MockIEngine
func (_mock *MockIEngine) AbortWorkflow(ctx context.Context, instanceID int64, requestedBy string, reason string) error {
	ret := _mock.Called(ctx, instanceID, requestedBy, reason)

	if len(ret) == 0 {
		panic("no return value specified for AbortWorkflow")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) error); ok {
		r0 = returnFunc(ctx, instanceID, requestedBy, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIEngine_AbortWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortWorkflow'
type MockIEngine_AbortWorkflow_Call struct {
	*mock.Call
}

// AbortWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - requestedBy string
//   - reason string
func (_e *MockIEngine_Expecter) AbortWorkflow(ctx interface{}, instanceID interface{}, requestedBy interface{}, reason interface{}) *MockIEngine_AbortWorkflow_Call {
	return &MockIEngine_AbortWorkflow_Call{Call: _e.mock.On("AbortWorkflow", ctx, instanceID, requestedBy, reason)}
}

func (_c *MockIEngine_AbortWorkflow_Call) Run(run func(ctx context.Context, instanceID int64, requestedBy string, reason string)) *MockIEngine_AbortWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockIEngine_AbortWorkflow_Call) Return(err error) *MockIEngine_AbortWorkflow_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIEngine_AbortWorkflow_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, requestedBy string, reason string) error) *MockIEngine_AbortWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// CancelWorkflow provides a mock function for the type MockIEngine
func (_mock *MockIEngine) CancelWorkflow(ctx context.Context, instanceID int64, requestedBy string, reason string) error {
	ret := _mock.Called(ctx, instanceID, requestedBy, reason)

	if len(ret) == 0 {
		panic("no return value specified for CancelWorkflow")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) error); ok {
		r0 = returnFunc(ctx, instanceID, requestedBy, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIEngine_CancelWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelWorkflow'
type MockIEngine_CancelWorkflow_Call struct {
	*mock.Call
}

// CancelWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - requestedBy string
//   - reason string
func (_e *MockIEngine_Expecter) CancelWorkflow(ctx interface{}, instanceID interface{}, requestedBy interface{}, reason interface{}) *MockIEngine_CancelWorkflow_Call {
	return &MockIEngine_CancelWorkflow_Call{Call: _e.mock.On("CancelWorkflow", ctx, instanceID, requestedBy, reason)}
}

func (_c *MockIEngine_CancelWorkflow_Call) Run(run func(ctx context.Context, instanceID int64, requestedBy string, reason string)) *MockIEngine_CancelWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockIEngine_CancelWorkflow_Call) Return(err error) *MockIEngine_CancelWorkflow_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIEngine_CancelWorkflow_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, requestedBy string, reason string) error) *MockIEngine_CancelWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// MakeHumanDecision provides a mock function for the type MockIEngine
func (_mock *MockIEngine) MakeHumanDecision(ctx context.Context, stepID int64, decidedBy string, decision HumanDecision, comment *string) error {
	ret := _mock.Called(ctx, stepID, decidedBy, decision, comment)

	if len(ret) == 0 {
		panic("no return value specified for MakeHumanDecision")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, HumanDecision, *string) error); ok {
		r0 = returnFunc(ctx, stepID, decidedBy, decision, comment)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIEngine_MakeHumanDecision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeHumanDecision'
type MockIEngine_MakeHumanDecision_Call struct {
	*mock.Call
}

// MakeHumanDecision is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - decidedBy string
//   - decision HumanDecision
//   - comment *string
func (_e *MockIEngine_Expecter) MakeHumanDecision(ctx interface{}, stepID interface{}, decidedBy interface{}, decision interface{}, comment interface{}) *MockIEngine_MakeHumanDecision_Call {
	return &MockIEngine_MakeHumanDecision_Call{Call: _e.mock.On("MakeHumanDecision", ctx, stepID, decidedBy, decision, comment)}
}

func (_c *MockIEngine_MakeHumanDecision_Call) Run(run func(ctx context.Context, stepID int64, decidedBy string, decision HumanDecision, comment *string)) *MockIEngine_MakeHumanDecision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 HumanDecision
		if args[3] != nil {
			arg3 = args[3].(HumanDecision)
		}
		var arg4 *string
		if args[4] != nil {
			arg4 = args[4].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockIEngine_MakeHumanDecision_Call) Return(err error) *MockIEngine_MakeHumanDecision_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIEngine_MakeHumanDecision_Call) RunAndReturn(run func(ctx context.Context, stepID int64, decidedBy string, decision HumanDecision, comment *string) error) *MockIEngine_MakeHumanDecision_Call {
	_c.Call.Return(run)
	return _c
}

// RequeueFromDLQ provides a mock function for the type MockIEngine
func (_mock *MockIEngine) RequeueFromDLQ(ctx context.Context, dlqID int64, newInput *json.RawMessage) error {
	ret := _mock.Called(ctx, dlqID, newInput)

	if len(ret) == 0 {
		panic("no return value specified for RequeueFromDLQ")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *json.RawMessage) error); ok {
		r0 = returnFunc(ctx, dlqID, newInput)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIEngine_RequeueFromDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequeueFromDLQ'
type MockIEngine_RequeueFromDLQ_Call struct {
	*mock.Call
}

// RequeueFromDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - dlqID int64
//   - newInput *json.RawMessage
func (_e *MockIEngine_Expecter) RequeueFromDLQ(ctx interface{}, dlqID interface{}, newInput interface{}) *MockIEngine_RequeueFromDLQ_Call {
	return &MockIEngine_RequeueFromDLQ_Call{Call: _e.mock.On("RequeueFromDLQ", ctx, dlqID, newInput)}
}

func (_c *MockIEngine_RequeueFromDLQ_Call) Run(run func(ctx context.Context, dlqID int64, newInput *json.RawMessage)) *MockIEngine_RequeueFromDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(*json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIEngine_RequeueFromDLQ_Call) Return(err error) *MockIEngine_RequeueFromDLQ_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIEngine_RequeueFromDLQ_Call) RunAndReturn(run func(ctx context.Context, dlqID int64, newInput *json.RawMessage) error) *MockIEngine_RequeueFromDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMonitor creates a new instance of MockMonitor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMonitor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMonitor {
	mock := &MockMonitor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMonitor is an autogenerated mock type for the Monitor type
type MockMonitor struct {
	mock.Mock
}

type MockMonitor_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMonitor) EXPECT() *MockMonitor_Expecter {
	return &MockMonitor_Expecter{mock: &_m.Mock}
}

// GetWorkflowStats provides a mock function for the type MockMonitor
func (_mock *MockMonitor) GetWorkflowStats(ctx context.Context) ([]WorkflowStats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowStats")
	}

	var r0 []WorkflowStats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]WorkflowStats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []WorkflowStats); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowStats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMonitor_GetWorkflowStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowStats'
type MockMonitor_GetWorkflowStats_Call struct {
	*mock.Call
}

// GetWorkflowStats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMonitor_Expecter) GetWorkflowStats(ctx interface{}) *MockMonitor_GetWorkflowStats_Call {
	return &MockMonitor_GetWorkflowStats_Call{Call: _e.mock.On("GetWorkflowStats", ctx)}
}

func (_c *MockMonitor_GetWorkflowStats_Call) Run(run func(ctx context.Context)) *MockMonitor_GetWorkflowStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMonitor_GetWorkflowStats_Call) Return(workflowStatss []WorkflowStats, err error) *MockMonitor_GetWorkflowStats_Call {
	_c.Call.Return(workflowStatss, err)
	return _c
}

func (_c *MockMonitor_GetWorkflowStats_Call) RunAndReturn(run func(ctx context.Context) ([]WorkflowStats, error)) *MockMonitor_GetWorkflowStats_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPlugin creates a new instance of MockPlugin. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPlugin(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPlugin {
	mock := &MockPlugin{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPlugin is an autogenerated mock type for the Plugin type
type MockPlugin struct {
	mock.Mock
}

type MockPlugin_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPlugin) EXPECT() *MockPlugin_Expecter {
	return &MockPlugin_Expecter{mock: &_m.Mock}
}

// Name provides a mock function for the type MockPlugin
func (_mock *MockPlugin) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockPlugin_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockPlugin_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockPlugin_Expecter) Name() *MockPlugin_Name_Call {
	return &MockPlugin_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockPlugin_Name_Call) Run(run func()) *MockPlugin_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPlugin_Name_Call) Return(s string) *MockPlugin_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockPlugin_Name_Call) RunAndReturn(run func() string) *MockPlugin_Name_Call {
	_c.Call.Return(run)
	return _c
}

// OnRollbackStepChain provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnRollbackStepChain(ctx context.Context, instanceID int64, stepName string, depth int) error {
	ret := _mock.Called(ctx, instanceID, stepName, depth)

	if len(ret) == 0 {
		panic("no return value specified for OnRollbackStepChain")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int) error); ok {
		r0 = returnFunc(ctx, instanceID, stepName, depth)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnRollbackStepChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnRollbackStepChain'
type MockPlugin_OnRollbackStepChain_Call struct {
	*mock.Call
}

// OnRollbackStepChain is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - stepName string
//   - depth int
func (_e *MockPlugin_Expecter) OnRollbackStepChain(ctx interface{}, instanceID interface{}, stepName interface{}, depth interface{}) *MockPlugin_OnRollbackStepChain_Call {
	return &MockPlugin_OnRollbackStepChain_Call{Call: _e.mock.On("OnRollbackStepChain", ctx, instanceID, stepName, depth)}
}

func (_c *MockPlugin_OnRollbackStepChain_Call) Run(run func(ctx context.Context, instanceID int64, stepName string, depth int)) *MockPlugin_OnRollbackStepChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPlugin_OnRollbackStepChain_Call) Return(err error) *MockPlugin_OnRollbackStepChain_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnRollbackStepChain_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, stepName string, depth int) error) *MockPlugin_OnRollbackStepChain_Call {
	_c.Call.Return(run)
	return _c
}

// OnStepComplete provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnStepComplete(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep) error {
	ret := _mock.Called(ctx, instance, step)

	if len(ret) == 0 {
		panic("no return value specified for OnStepComplete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance, *WorkflowStep) error); ok {
		r0 = returnFunc(ctx, instance, step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnStepComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStepComplete'
type MockPlugin_OnStepComplete_Call struct {
	*mock.Call
}

// OnStepComplete is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
//   - step *WorkflowStep
func (_e *MockPlugin_Expecter) OnStepComplete(ctx interface{}, instance interface{}, step interface{}) *MockPlugin_OnStepComplete_Call {
	return &MockPlugin_OnStepComplete_Call{Call: _e.mock.On("OnStepComplete", ctx, instance, step)}
}

func (_c *MockPlugin_OnStepComplete_Call) Run(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep)) *MockPlugin_OnStepComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		var arg2 *WorkflowStep
		if args[2] != nil {
			arg2 = args[2].(*WorkflowStep)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPlugin_OnStepComplete_Call) Return(err error) *MockPlugin_OnStepComplete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnStepComplete_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep) error) *MockPlugin_OnStepComplete_Call {
	_c.Call.Return(run)
	return _c
}

// OnStepFailed provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnStepFailed(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep, err error) error {
	ret := _mock.Called(ctx, instance, step, err)

	if len(ret) == 0 {
		panic("no return value specified for OnStepFailed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance, *WorkflowStep, error) error); ok {
		r0 = returnFunc(ctx, instance, step, err)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnStepFailed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStepFailed'
type MockPlugin_OnStepFailed_Call struct {
	*mock.Call
}

// OnStepFailed is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
//   - step *WorkflowStep
//   - err error
func (_e *MockPlugin_Expecter) OnStepFailed(ctx interface{}, instance interface{}, step interface{}, err interface{}) *MockPlugin_OnStepFailed_Call {
	return &MockPlugin_OnStepFailed_Call{Call: _e.mock.On("OnStepFailed", ctx, instance, step, err)}
}

func (_c *MockPlugin_OnStepFailed_Call) Run(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep, err error)) *MockPlugin_OnStepFailed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		var arg2 *WorkflowStep
		if args[2] != nil {
			arg2 = args[2].(*WorkflowStep)
		}
		var arg3 error
		if args[3] != nil {
			arg3 = args[3].(error)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPlugin_OnStepFailed_Call) Return(err1 error) *MockPlugin_OnStepFailed_Call {
	_c.Call.Return(err1)
	return _c
}

func (_c *MockPlugin_OnStepFailed_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep, err error) error) *MockPlugin_OnStepFailed_Call {
	_c.Call.Return(run)
	return _c
}

// OnStepStart provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnStepStart(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep) error {
	ret := _mock.Called(ctx, instance, step)

	if len(ret) == 0 {
		panic("no return value specified for OnStepStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance, *WorkflowStep) error); ok {
		r0 = returnFunc(ctx, instance, step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnStepStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStepStart'
type MockPlugin_OnStepStart_Call struct {
	*mock.Call
}

// OnStepStart is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
//   - step *WorkflowStep
func (_e *MockPlugin_Expecter) OnStepStart(ctx interface{}, instance interface{}, step interface{}) *MockPlugin_OnStepStart_Call {
	return &MockPlugin_OnStepStart_Call{Call: _e.mock.On("OnStepStart", ctx, instance, step)}
}

func (_c *MockPlugin_OnStepStart_Call) Run(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep)) *MockPlugin_OnStepStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		var arg2 *WorkflowStep
		if args[2] != nil {
			arg2 = args[2].(*WorkflowStep)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPlugin_OnStepStart_Call) Return(err error) *MockPlugin_OnStepStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnStepStart_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance, step *WorkflowStep) error) *MockPlugin_OnStepStart_Call {
	_c.Call.Return(run)
	return _c
}

// OnWorkflowComplete provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnWorkflowComplete(ctx context.Context, instance *WorkflowInstance) error {
	ret := _mock.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for OnWorkflowComplete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance) error); ok {
		r0 = returnFunc(ctx, instance)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnWorkflowComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnWorkflowComplete'
type MockPlugin_OnWorkflowComplete_Call struct {
	*mock.Call
}

// OnWorkflowComplete is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
func (_e *MockPlugin_Expecter) OnWorkflowComplete(ctx interface{}, instance interface{}) *MockPlugin_OnWorkflowComplete_Call {
	return &MockPlugin_OnWorkflowComplete_Call{Call: _e.mock.On("OnWorkflowComplete", ctx, instance)}
}

func (_c *MockPlugin_OnWorkflowComplete_Call) Run(run func(ctx context.Context, instance *WorkflowInstance)) *MockPlugin_OnWorkflowComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPlugin_OnWorkflowComplete_Call) Return(err error) *MockPlugin_OnWorkflowComplete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnWorkflowComplete_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance) error) *MockPlugin_OnWorkflowComplete_Call {
	_c.Call.Return(run)
	return _c
}

// OnWorkflowFailed provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnWorkflowFailed(ctx context.Context, instance *WorkflowInstance) error {
	ret := _mock.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for OnWorkflowFailed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance) error); ok {
		r0 = returnFunc(ctx, instance)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnWorkflowFailed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnWorkflowFailed'
type MockPlugin_OnWorkflowFailed_Call struct {
	*mock.Call
}

// OnWorkflowFailed is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
func (_e *MockPlugin_Expecter) OnWorkflowFailed(ctx interface{}, instance interface{}) *MockPlugin_OnWorkflowFailed_Call {
	return &MockPlugin_OnWorkflowFailed_Call{Call: _e.mock.On("OnWorkflowFailed", ctx, instance)}
}

func (_c *MockPlugin_OnWorkflowFailed_Call) Run(run func(ctx context.Context, instance *WorkflowInstance)) *MockPlugin_OnWorkflowFailed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPlugin_OnWorkflowFailed_Call) Return(err error) *MockPlugin_OnWorkflowFailed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnWorkflowFailed_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance) error) *MockPlugin_OnWorkflowFailed_Call {
	_c.Call.Return(run)
	return _c
}

// OnWorkflowStart provides a mock function for the type MockPlugin
func (_mock *MockPlugin) OnWorkflowStart(ctx context.Context, instance *WorkflowInstance) error {
	ret := _mock.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for OnWorkflowStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowInstance) error); ok {
		r0 = returnFunc(ctx, instance)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlugin_OnWorkflowStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnWorkflowStart'
type MockPlugin_OnWorkflowStart_Call struct {
	*mock.Call
}

// OnWorkflowStart is a helper method to define mock.On call
//   - ctx context.Context
//   - instance *WorkflowInstance
func (_e *MockPlugin_Expecter) OnWorkflowStart(ctx interface{}, instance interface{}) *MockPlugin_OnWorkflowStart_Call {
	return &MockPlugin_OnWorkflowStart_Call{Call: _e.mock.On("OnWorkflowStart", ctx, instance)}
}

func (_c *MockPlugin_OnWorkflowStart_Call) Run(run func(ctx context.Context, instance *WorkflowInstance)) *MockPlugin_OnWorkflowStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowInstance
		if args[1] != nil {
			arg1 = args[1].(*WorkflowInstance)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPlugin_OnWorkflowStart_Call) Return(err error) *MockPlugin_OnWorkflowStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlugin_OnWorkflowStart_Call) RunAndReturn(run func(ctx context.Context, instance *WorkflowInstance) error) *MockPlugin_OnWorkflowStart_Call {
	_c.Call.Return(run)
	return _c
}

// Priority provides a mock function for the type MockPlugin
func (_mock *MockPlugin) Priority() Priority {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Priority")
	}

	var r0 Priority
	if returnFunc, ok := ret.Get(0).(func() Priority); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(Priority)
	}
	return r0
}

// MockPlugin_Priority_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Priority'
type MockPlugin_Priority_Call struct {
	*mock.Call
}

// Priority is a helper method to define mock.On call
func (_e *MockPlugin_Expecter) Priority() *MockPlugin_Priority_Call {
	return &MockPlugin_Priority_Call{Call: _e.mock.On("Priority")}
}

func (_c *MockPlugin_Priority_Call) Run(run func()) *MockPlugin_Priority_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPlugin_Priority_Call) Return(priority Priority) *MockPlugin_Priority_Call {
	_c.Call.Return(priority)
	return _c
}

func (_c *MockPlugin_Priority_Call) RunAndReturn(run func() Priority) *MockPlugin_Priority_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStepHandler creates a new instance of MockStepHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStepHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStepHandler {
	mock := &MockStepHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStepHandler is an autogenerated mock type for the StepHandler type
type MockStepHandler struct {
	mock.Mock
}

type MockStepHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStepHandler) EXPECT() *MockStepHandler_Expecter {
	return &MockStepHandler_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockStepHandler
func (_mock *MockStepHandler) Execute(ctx context.Context, stepCtx StepContext, input json.RawMessage) (json.RawMessage, error) {
	ret := _mock.Called(ctx, stepCtx, input)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 json.RawMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, StepContext, json.RawMessage) (json.RawMessage, error)); ok {
		return returnFunc(ctx, stepCtx, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, StepContext, json.RawMessage) json.RawMessage); ok {
		r0 = returnFunc(ctx, stepCtx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, StepContext, json.RawMessage) error); ok {
		r1 = returnFunc(ctx, stepCtx, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStepHandler_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockStepHandler_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - stepCtx StepContext
//   - input json.RawMessage
func (_e *MockStepHandler_Expecter) Execute(ctx interface{}, stepCtx interface{}, input interface{}) *MockStepHandler_Execute_Call {
	return &MockStepHandler_Execute_Call{Call: _e.mock.On("Execute", ctx, stepCtx, input)}
}

func (_c *MockStepHandler_Execute_Call) Run(run func(ctx context.Context, stepCtx StepContext, input json.RawMessage)) *MockStepHandler_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 StepContext
		if args[1] != nil {
			arg1 = args[1].(StepContext)
		}
		var arg2 json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStepHandler_Execute_Call) Return(rawMessage json.RawMessage, err error) *MockStepHandler_Execute_Call {
	_c.Call.Return(rawMessage, err)
	return _c
}

func (_c *MockStepHandler_Execute_Call) RunAndReturn(run func(ctx context.Context, stepCtx StepContext, input json.RawMessage) (json.RawMessage, error)) *MockStepHandler_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockStepHandler
func (_mock *MockStepHandler) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockStepHandler_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockStepHandler_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockStepHandler_Expecter) Name() *MockStepHandler_Name_Call {
	return &MockStepHandler_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockStepHandler_Name_Call) Run(run func()) *MockStepHandler_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepHandler_Name_Call) Return(s string) *MockStepHandler_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockStepHandler_Name_Call) RunAndReturn(run func() string) *MockStepHandler_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStepContext creates a new instance of MockStepContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStepContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStepContext {
	mock := &MockStepContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStepContext is an autogenerated mock type for the StepContext type
type MockStepContext struct {
	mock.Mock
}

type MockStepContext_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStepContext) EXPECT() *MockStepContext_Expecter {
	return &MockStepContext_Expecter{mock: &_m.Mock}
}

// CloneData provides a mock function for the type MockStepContext
func (_mock *MockStepContext) CloneData() map[string]any {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CloneData")
	}

	var r0 map[string]any
	if returnFunc, ok := ret.Get(0).(func() map[string]any); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}
	return r0
}

// MockStepContext_CloneData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloneData'
type MockStepContext_CloneData_Call struct {
	*mock.Call
}

// CloneData is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) CloneData() *MockStepContext_CloneData_Call {
	return &MockStepContext_CloneData_Call{Call: _e.mock.On("CloneData")}
}

func (_c *MockStepContext_CloneData_Call) Run(run func()) *MockStepContext_CloneData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_CloneData_Call) Return(stringToV map[string]any) *MockStepContext_CloneData_Call {
	_c.Call.Return(stringToV)
	return _c
}

func (_c *MockStepContext_CloneData_Call) RunAndReturn(run func() map[string]any) *MockStepContext_CloneData_Call {
	_c.Call.Return(run)
	return _c
}

// GetVariable provides a mock function for the type MockStepContext
func (_mock *MockStepContext) GetVariable(key string) (any, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetVariable")
	}

	var r0 any
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (any, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(string) any); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockStepContext_GetVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVariable'
type MockStepContext_GetVariable_Call struct {
	*mock.Call
}

// GetVariable is a helper method to define mock.On call
//   - key string
func (_e *MockStepContext_Expecter) GetVariable(key interface{}) *MockStepContext_GetVariable_Call {
	return &MockStepContext_GetVariable_Call{Call: _e.mock.On("GetVariable", key)}
}

func (_c *MockStepContext_GetVariable_Call) Run(run func(key string)) *MockStepContext_GetVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStepContext_GetVariable_Call) Return(v any, b bool) *MockStepContext_GetVariable_Call {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MockStepContext_GetVariable_Call) RunAndReturn(run func(key string) (any, bool)) *MockStepContext_GetVariable_Call {
	_c.Call.Return(run)
	return _c
}

// GetVariableAsString provides a mock function for the type MockStepContext
func (_mock *MockStepContext) GetVariableAsString(key string) (string, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetVariableAsString")
	}

	var r0 string
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (string, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockStepContext_GetVariableAsString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVariableAsString'
type MockStepContext_GetVariableAsString_Call struct {
	*mock.Call
}

// GetVariableAsString is a helper method to define mock.On call
//   - key string
func (_e *MockStepContext_Expecter) GetVariableAsString(key interface{}) *MockStepContext_GetVariableAsString_Call {
	return &MockStepContext_GetVariableAsString_Call{Call: _e.mock.On("GetVariableAsString", key)}
}

func (_c *MockStepContext_GetVariableAsString_Call) Run(run func(key string)) *MockStepContext_GetVariableAsString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStepContext_GetVariableAsString_Call) Return(s string, b bool) *MockStepContext_GetVariableAsString_Call {
	_c.Call.Return(s, b)
	return _c
}

func (_c *MockStepContext_GetVariableAsString_Call) RunAndReturn(run func(key string) (string, bool)) *MockStepContext_GetVariableAsString_Call {
	_c.Call.Return(run)
	return _c
}

// IdempotencyKey provides a mock function for the type MockStepContext
func (_mock *MockStepContext) IdempotencyKey() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IdempotencyKey")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockStepContext_IdempotencyKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdempotencyKey'
type MockStepContext_IdempotencyKey_Call struct {
	*mock.Call
}

// IdempotencyKey is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) IdempotencyKey() *MockStepContext_IdempotencyKey_Call {
	return &MockStepContext_IdempotencyKey_Call{Call: _e.mock.On("IdempotencyKey")}
}

func (_c *MockStepContext_IdempotencyKey_Call) Run(run func()) *MockStepContext_IdempotencyKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_IdempotencyKey_Call) Return(s string) *MockStepContext_IdempotencyKey_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockStepContext_IdempotencyKey_Call) RunAndReturn(run func() string) *MockStepContext_IdempotencyKey_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceID provides a mock function for the type MockStepContext
func (_mock *MockStepContext) InstanceID() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for InstanceID")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// MockStepContext_InstanceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceID'
type MockStepContext_InstanceID_Call struct {
	*mock.Call
}

// InstanceID is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) InstanceID() *MockStepContext_InstanceID_Call {
	return &MockStepContext_InstanceID_Call{Call: _e.mock.On("InstanceID")}
}

func (_c *MockStepContext_InstanceID_Call) Run(run func()) *MockStepContext_InstanceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_InstanceID_Call) Return(n int64) *MockStepContext_InstanceID_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockStepContext_InstanceID_Call) RunAndReturn(run func() int64) *MockStepContext_InstanceID_Call {
	_c.Call.Return(run)
	return _c
}

// RetryCount provides a mock function for the type MockStepContext
func (_mock *MockStepContext) RetryCount() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RetryCount")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockStepContext_RetryCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryCount'
type MockStepContext_RetryCount_Call struct {
	*mock.Call
}

// RetryCount is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) RetryCount() *MockStepContext_RetryCount_Call {
	return &MockStepContext_RetryCount_Call{Call: _e.mock.On("RetryCount")}
}

func (_c *MockStepContext_RetryCount_Call) Run(run func()) *MockStepContext_RetryCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_RetryCount_Call) Return(n int) *MockStepContext_RetryCount_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockStepContext_RetryCount_Call) RunAndReturn(run func() int) *MockStepContext_RetryCount_Call {
	_c.Call.Return(run)
	return _c
}

// StepName provides a mock function for the type MockStepContext
func (_mock *MockStepContext) StepName() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StepName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockStepContext_StepName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StepName'
type MockStepContext_StepName_Call struct {
	*mock.Call
}

// StepName is a helper method to define mock.On call
func (_e *MockStepContext_Expecter) StepName() *MockStepContext_StepName_Call {
	return &MockStepContext_StepName_Call{Call: _e.mock.On("StepName")}
}

func (_c *MockStepContext_StepName_Call) Run(run func()) *MockStepContext_StepName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStepContext_StepName_Call) Return(s string) *MockStepContext_StepName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockStepContext_StepName_Call) RunAndReturn(run func() string) *MockStepContext_StepName_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// AddToJoinWaitFor provides a mock function for the type MockStore
func (_mock *MockStore) AddToJoinWaitFor(ctx context.Context, instanceID int64, joinStepName string, stepToAdd string) error {
	ret := _mock.Called(ctx, instanceID, joinStepName, stepToAdd)

	if len(ret) == 0 {
		panic("no return value specified for AddToJoinWaitFor")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) error); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, stepToAdd)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_AddToJoinWaitFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToJoinWaitFor'
type MockStore_AddToJoinWaitFor_Call struct {
	*mock.Call
}

// AddToJoinWaitFor is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - stepToAdd string
func (_e *MockStore_Expecter) AddToJoinWaitFor(ctx interface{}, instanceID interface{}, joinStepName interface{}, stepToAdd interface{}) *MockStore_AddToJoinWaitFor_Call {
	return &MockStore_AddToJoinWaitFor_Call{Call: _e.mock.On("AddToJoinWaitFor", ctx, instanceID, joinStepName, stepToAdd)}
}

func (_c *MockStore_AddToJoinWaitFor_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, stepToAdd string)) *MockStore_AddToJoinWaitFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_AddToJoinWaitFor_Call) Return(err error) *MockStore_AddToJoinWaitFor_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_AddToJoinWaitFor_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, stepToAdd string) error) *MockStore_AddToJoinWaitFor_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupOldWorkflows provides a mock function for the type MockStore
func (_mock *MockStore) CleanupOldWorkflows(ctx context.Context, daysToKeep int) (int64, error) {
	ret := _mock.Called(ctx, daysToKeep)

	if len(ret) == 0 {
		panic("no return value specified for CleanupOldWorkflows")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (int64, error)); ok {
		return returnFunc(ctx, daysToKeep)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) int64); ok {
		r0 = returnFunc(ctx, daysToKeep)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, daysToKeep)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CleanupOldWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupOldWorkflows'
type MockStore_CleanupOldWorkflows_Call struct {
	*mock.Call
}

// CleanupOldWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - daysToKeep int
func (_e *MockStore_Expecter) CleanupOldWorkflows(ctx interface{}, daysToKeep interface{}) *MockStore_CleanupOldWorkflows_Call {
	return &MockStore_CleanupOldWorkflows_Call{Call: _e.mock.On("CleanupOldWorkflows", ctx, daysToKeep)}
}

func (_c *MockStore_CleanupOldWorkflows_Call) Run(run func(ctx context.Context, daysToKeep int)) *MockStore_CleanupOldWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CleanupOldWorkflows_Call) Return(n int64, err error) *MockStore_CleanupOldWorkflows_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_CleanupOldWorkflows_Call) RunAndReturn(run func(ctx context.Context, daysToKeep int) (int64, error)) *MockStore_CleanupOldWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCancelRequest provides a mock function for the type MockStore
func (_mock *MockStore) CreateCancelRequest(ctx context.Context, req *WorkflowCancelRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateCancelRequest")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowCancelRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateCancelRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCancelRequest'
type MockStore_CreateCancelRequest_Call struct {
	*mock.Call
}

// CreateCancelRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - req *WorkflowCancelRequest
func (_e *MockStore_Expecter) CreateCancelRequest(ctx interface{}, req interface{}) *MockStore_CreateCancelRequest_Call {
	return &MockStore_CreateCancelRequest_Call{Call: _e.mock.On("CreateCancelRequest", ctx, req)}
}

func (_c *MockStore_CreateCancelRequest_Call) Run(run func(ctx context.Context, req *WorkflowCancelRequest)) *MockStore_CreateCancelRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowCancelRequest
		if args[1] != nil {
			arg1 = args[1].(*WorkflowCancelRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateCancelRequest_Call) Return(err error) *MockStore_CreateCancelRequest_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateCancelRequest_Call) RunAndReturn(run func(ctx context.Context, req *WorkflowCancelRequest) error) *MockStore_CreateCancelRequest_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDeadLetterRecord provides a mock function for the type MockStore
func (_mock *MockStore) CreateDeadLetterRecord(ctx context.Context, rec *DeadLetterRecord) error {
	ret := _mock.Called(ctx, rec)

	if len(ret) == 0 {
		panic("no return value specified for CreateDeadLetterRecord")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *DeadLetterRecord) error); ok {
		r0 = returnFunc(ctx, rec)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateDeadLetterRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDeadLetterRecord'
type MockStore_CreateDeadLetterRecord_Call struct {
	*mock.Call
}

// CreateDeadLetterRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - rec *DeadLetterRecord
func (_e *MockStore_Expecter) CreateDeadLetterRecord(ctx interface{}, rec interface{}) *MockStore_CreateDeadLetterRecord_Call {
	return &MockStore_CreateDeadLetterRecord_Call{Call: _e.mock.On("CreateDeadLetterRecord", ctx, rec)}
}

func (_c *MockStore_CreateDeadLetterRecord_Call) Run(run func(ctx context.Context, rec *DeadLetterRecord)) *MockStore_CreateDeadLetterRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *DeadLetterRecord
		if args[1] != nil {
			arg1 = args[1].(*DeadLetterRecord)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateDeadLetterRecord_Call) Return(err error) *MockStore_CreateDeadLetterRecord_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateDeadLetterRecord_Call) RunAndReturn(run func(ctx context.Context, rec *DeadLetterRecord) error) *MockStore_CreateDeadLetterRecord_Call {
	_c.Call.Return(run)
	return _c
}

// CreateHumanDecision provides a mock function for the type MockStore
func (_mock *MockStore) CreateHumanDecision(ctx context.Context, decision *HumanDecisionRecord) error {
	ret := _mock.Called(ctx, decision)

	if len(ret) == 0 {
		panic("no return value specified for CreateHumanDecision")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *HumanDecisionRecord) error); ok {
		r0 = returnFunc(ctx, decision)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateHumanDecision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateHumanDecision'
type MockStore_CreateHumanDecision_Call struct {
	*mock.Call
}

// CreateHumanDecision is a helper method to define mock.On call
//   - ctx context.Context
//   - decision *HumanDecisionRecord
func (_e *MockStore_Expecter) CreateHumanDecision(ctx interface{}, decision interface{}) *MockStore_CreateHumanDecision_Call {
	return &MockStore_CreateHumanDecision_Call{Call: _e.mock.On("CreateHumanDecision", ctx, decision)}
}

func (_c *MockStore_CreateHumanDecision_Call) Run(run func(ctx context.Context, decision *HumanDecisionRecord)) *MockStore_CreateHumanDecision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *HumanDecisionRecord
		if args[1] != nil {
			arg1 = args[1].(*HumanDecisionRecord)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateHumanDecision_Call) Return(err error) *MockStore_CreateHumanDecision_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateHumanDecision_Call) RunAndReturn(run func(ctx context.Context, decision *HumanDecisionRecord) error) *MockStore_CreateHumanDecision_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInstance provides a mock function for the type MockStore
func (_mock *MockStore) CreateInstance(ctx context.Context, workflowID string, input json.RawMessage) (*WorkflowInstance, error) {
	ret := _mock.Called(ctx, workflowID, input)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstance")
	}

	var r0 *WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, json.RawMessage) (*WorkflowInstance, error)); ok {
		return returnFunc(ctx, workflowID, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, json.RawMessage) *WorkflowInstance); ok {
		r0 = returnFunc(ctx, workflowID, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, json.RawMessage) error); ok {
		r1 = returnFunc(ctx, workflowID, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_CreateInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInstance'
type MockStore_CreateInstance_Call struct {
	*mock.Call
}

// CreateInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowID string
//   - input json.RawMessage
func (_e *MockStore_Expecter) CreateInstance(ctx interface{}, workflowID interface{}, input interface{}) *MockStore_CreateInstance_Call {
	return &MockStore_CreateInstance_Call{Call: _e.mock.On("CreateInstance", ctx, workflowID, input)}
}

func (_c *MockStore_CreateInstance_Call) Run(run func(ctx context.Context, workflowID string, input json.RawMessage)) *MockStore_CreateInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_CreateInstance_Call) Return(workflowInstance *WorkflowInstance, err error) *MockStore_CreateInstance_Call {
	_c.Call.Return(workflowInstance, err)
	return _c
}

func (_c *MockStore_CreateInstance_Call) RunAndReturn(run func(ctx context.Context, workflowID string, input json.RawMessage) (*WorkflowInstance, error)) *MockStore_CreateInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJoinState provides a mock function for the type MockStore
func (_mock *MockStore) CreateJoinState(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy) error {
	ret := _mock.Called(ctx, instanceID, joinStepName, waitingFor, strategy)

	if len(ret) == 0 {
		panic("no return value specified for CreateJoinState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, []string, JoinStrategy) error); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, waitingFor, strategy)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJoinState'
type MockStore_CreateJoinState_Call struct {
	*mock.Call
}

// CreateJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - waitingFor []string
//   - strategy JoinStrategy
func (_e *MockStore_Expecter) CreateJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}, waitingFor interface{}, strategy interface{}) *MockStore_CreateJoinState_Call {
	return &MockStore_CreateJoinState_Call{Call: _e.mock.On("CreateJoinState", ctx, instanceID, joinStepName, waitingFor, strategy)}
}

func (_c *MockStore_CreateJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy)) *MockStore_CreateJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []string
		if args[3] != nil {
			arg3 = args[3].([]string)
		}
		var arg4 JoinStrategy
		if args[4] != nil {
			arg4 = args[4].(JoinStrategy)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_CreateJoinState_Call) Return(err error) *MockStore_CreateJoinState_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, waitingFor []string, strategy JoinStrategy) error) *MockStore_CreateJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStep provides a mock function for the type MockStore
func (_mock *MockStore) CreateStep(ctx context.Context, step *WorkflowStep) error {
	ret := _mock.Called(ctx, step)

	if len(ret) == 0 {
		panic("no return value specified for CreateStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowStep) error); ok {
		r0 = returnFunc(ctx, step)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStep'
type MockStore_CreateStep_Call struct {
	*mock.Call
}

// CreateStep is a helper method to define mock.On call
//   - ctx context.Context
//   - step *WorkflowStep
func (_e *MockStore_Expecter) CreateStep(ctx interface{}, step interface{}) *MockStore_CreateStep_Call {
	return &MockStore_CreateStep_Call{Call: _e.mock.On("CreateStep", ctx, step)}
}

func (_c *MockStore_CreateStep_Call) Run(run func(ctx context.Context, step *WorkflowStep)) *MockStore_CreateStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowStep
		if args[1] != nil {
			arg1 = args[1].(*WorkflowStep)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateStep_Call) Return(err error) *MockStore_CreateStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateStep_Call) RunAndReturn(run func(ctx context.Context, step *WorkflowStep) error) *MockStore_CreateStep_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCancelRequest provides a mock function for the type MockStore
func (_mock *MockStore) DeleteCancelRequest(ctx context.Context, instanceID int64) error {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCancelRequest")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_DeleteCancelRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCancelRequest'
type MockStore_DeleteCancelRequest_Call struct {
	*mock.Call
}

// DeleteCancelRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) DeleteCancelRequest(ctx interface{}, instanceID interface{}) *MockStore_DeleteCancelRequest_Call {
	return &MockStore_DeleteCancelRequest_Call{Call: _e.mock.On("DeleteCancelRequest", ctx, instanceID)}
}

func (_c *MockStore_DeleteCancelRequest_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_DeleteCancelRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_DeleteCancelRequest_Call) Return(err error) *MockStore_DeleteCancelRequest_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_DeleteCancelRequest_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) error) *MockStore_DeleteCancelRequest_Call {
	_c.Call.Return(run)
	return _c
}

// DequeueStep provides a mock function for the type MockStore
func (_mock *MockStore) DequeueStep(ctx context.Context, workerID string) (*QueueItem, error) {
	ret := _mock.Called(ctx, workerID)

	if len(ret) == 0 {
		panic("no return value specified for DequeueStep")
	}

	var r0 *QueueItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*QueueItem, error)); ok {
		return returnFunc(ctx, workerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *QueueItem); ok {
		r0 = returnFunc(ctx, workerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*QueueItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, workerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DequeueStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DequeueStep'
type MockStore_DequeueStep_Call struct {
	*mock.Call
}

// DequeueStep is a helper method to define mock.On call
//   - ctx context.Context
//   - workerID string
func (_e *MockStore_Expecter) DequeueStep(ctx interface{}, workerID interface{}) *MockStore_DequeueStep_Call {
	return &MockStore_DequeueStep_Call{Call: _e.mock.On("DequeueStep", ctx, workerID)}
}

func (_c *MockStore_DequeueStep_Call) Run(run func(ctx context.Context, workerID string)) *MockStore_DequeueStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_DequeueStep_Call) Return(queueItem *QueueItem, err error) *MockStore_DequeueStep_Call {
	_c.Call.Return(queueItem, err)
	return _c
}

func (_c *MockStore_DequeueStep_Call) RunAndReturn(run func(ctx context.Context, workerID string) (*QueueItem, error)) *MockStore_DequeueStep_Call {
	_c.Call.Return(run)
	return _c
}

// EnqueueStep provides a mock function for the type MockStore
func (_mock *MockStore) EnqueueStep(ctx context.Context, instanceID int64, stepID *int64, priority Priority, delay time.Duration) error {
	ret := _mock.Called(ctx, instanceID, stepID, priority, delay)

	if len(ret) == 0 {
		panic("no return value specified for EnqueueStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *int64, Priority, time.Duration) error); ok {
		r0 = returnFunc(ctx, instanceID, stepID, priority, delay)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_EnqueueStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnqueueStep'
type MockStore_EnqueueStep_Call struct {
	*mock.Call
}

// EnqueueStep is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - stepID *int64
//   - priority Priority
//   - delay time.Duration
func (_e *MockStore_Expecter) EnqueueStep(ctx interface{}, instanceID interface{}, stepID interface{}, priority interface{}, delay interface{}) *MockStore_EnqueueStep_Call {
	return &MockStore_EnqueueStep_Call{Call: _e.mock.On("EnqueueStep", ctx, instanceID, stepID, priority, delay)}
}

func (_c *MockStore_EnqueueStep_Call) Run(run func(ctx context.Context, instanceID int64, stepID *int64, priority Priority, delay time.Duration)) *MockStore_EnqueueStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *int64
		if args[2] != nil {
			arg2 = args[2].(*int64)
		}
		var arg3 Priority
		if args[3] != nil {
			arg3 = args[3].(Priority)
		}
		var arg4 time.Duration
		if args[4] != nil {
			arg4 = args[4].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_EnqueueStep_Call) Return(err error) *MockStore_EnqueueStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_EnqueueStep_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, stepID *int64, priority Priority, delay time.Duration) error) *MockStore_EnqueueStep_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveInstances provides a mock function for the type MockStore
func (_mock *MockStore) GetActiveInstances(ctx context.Context) ([]ActiveWorkflowInstance, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveInstances")
	}

	var r0 []ActiveWorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]ActiveWorkflowInstance, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []ActiveWorkflowInstance); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ActiveWorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetActiveInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveInstances'
type MockStore_GetActiveInstances_Call struct {
	*mock.Call
}

// GetActiveInstances is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetActiveInstances(ctx interface{}) *MockStore_GetActiveInstances_Call {
	return &MockStore_GetActiveInstances_Call{Call: _e.mock.On("GetActiveInstances", ctx)}
}

func (_c *MockStore_GetActiveInstances_Call) Run(run func(ctx context.Context)) *MockStore_GetActiveInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetActiveInstances_Call) Return(activeWorkflowInstances []ActiveWorkflowInstance, err error) *MockStore_GetActiveInstances_Call {
	_c.Call.Return(activeWorkflowInstances, err)
	return _c
}

func (_c *MockStore_GetActiveInstances_Call) RunAndReturn(run func(ctx context.Context) ([]ActiveWorkflowInstance, error)) *MockStore_GetActiveInstances_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveStepsForUpdate provides a mock function for the type MockStore
func (_mock *MockStore) GetActiveStepsForUpdate(ctx context.Context, instanceID int64) ([]WorkflowStep, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveStepsForUpdate")
	}

	var r0 []WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]WorkflowStep, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []WorkflowStep); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetActiveStepsForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveStepsForUpdate'
type MockStore_GetActiveStepsForUpdate_Call struct {
	*mock.Call
}

// GetActiveStepsForUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetActiveStepsForUpdate(ctx interface{}, instanceID interface{}) *MockStore_GetActiveStepsForUpdate_Call {
	return &MockStore_GetActiveStepsForUpdate_Call{Call: _e.mock.On("GetActiveStepsForUpdate", ctx, instanceID)}
}

func (_c *MockStore_GetActiveStepsForUpdate_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetActiveStepsForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetActiveStepsForUpdate_Call) Return(workflowSteps []WorkflowStep, err error) *MockStore_GetActiveStepsForUpdate_Call {
	_c.Call.Return(workflowSteps, err)
	return _c
}

func (_c *MockStore_GetActiveStepsForUpdate_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) ([]WorkflowStep, error)) *MockStore_GetActiveStepsForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllWorkflowInstances provides a mock function for the type MockStore
func (_mock *MockStore) GetAllWorkflowInstances(ctx context.Context) ([]WorkflowInstance, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllWorkflowInstances")
	}

	var r0 []WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]WorkflowInstance, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []WorkflowInstance); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetAllWorkflowInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllWorkflowInstances'
type MockStore_GetAllWorkflowInstances_Call struct {
	*mock.Call
}

// GetAllWorkflowInstances is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetAllWorkflowInstances(ctx interface{}) *MockStore_GetAllWorkflowInstances_Call {
	return &MockStore_GetAllWorkflowInstances_Call{Call: _e.mock.On("GetAllWorkflowInstances", ctx)}
}

func (_c *MockStore_GetAllWorkflowInstances_Call) Run(run func(ctx context.Context)) *MockStore_GetAllWorkflowInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetAllWorkflowInstances_Call) Return(workflowInstances []WorkflowInstance, err error) *MockStore_GetAllWorkflowInstances_Call {
	_c.Call.Return(workflowInstances, err)
	return _c
}

func (_c *MockStore_GetAllWorkflowInstances_Call) RunAndReturn(run func(ctx context.Context) ([]WorkflowInstance, error)) *MockStore_GetAllWorkflowInstances_Call {
	_c.Call.Return(run)
	return _c
}

// GetCancelRequest provides a mock function for the type MockStore
func (_mock *MockStore) GetCancelRequest(ctx context.Context, instanceID int64) (*WorkflowCancelRequest, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetCancelRequest")
	}

	var r0 *WorkflowCancelRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*WorkflowCancelRequest, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *WorkflowCancelRequest); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowCancelRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetCancelRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCancelRequest'
type MockStore_GetCancelRequest_Call struct {
	*mock.Call
}

// GetCancelRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetCancelRequest(ctx interface{}, instanceID interface{}) *MockStore_GetCancelRequest_Call {
	return &MockStore_GetCancelRequest_Call{Call: _e.mock.On("GetCancelRequest", ctx, instanceID)}
}

func (_c *MockStore_GetCancelRequest_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetCancelRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetCancelRequest_Call) Return(workflowCancelRequest *WorkflowCancelRequest, err error) *MockStore_GetCancelRequest_Call {
	_c.Call.Return(workflowCancelRequest, err)
	return _c
}

func (_c *MockStore_GetCancelRequest_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) (*WorkflowCancelRequest, error)) *MockStore_GetCancelRequest_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeadLetterByID provides a mock function for the type MockStore
func (_mock *MockStore) GetDeadLetterByID(ctx context.Context, id int64) (*DeadLetterRecord, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetDeadLetterByID")
	}

	var r0 *DeadLetterRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*DeadLetterRecord, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *DeadLetterRecord); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeadLetterRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetDeadLetterByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeadLetterByID'
type MockStore_GetDeadLetterByID_Call struct {
	*mock.Call
}

// GetDeadLetterByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockStore_Expecter) GetDeadLetterByID(ctx interface{}, id interface{}) *MockStore_GetDeadLetterByID_Call {
	return &MockStore_GetDeadLetterByID_Call{Call: _e.mock.On("GetDeadLetterByID", ctx, id)}
}

func (_c *MockStore_GetDeadLetterByID_Call) Run(run func(ctx context.Context, id int64)) *MockStore_GetDeadLetterByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetDeadLetterByID_Call) Return(deadLetterRecord *DeadLetterRecord, err error) *MockStore_GetDeadLetterByID_Call {
	_c.Call.Return(deadLetterRecord, err)
	return _c
}

func (_c *MockStore_GetDeadLetterByID_Call) RunAndReturn(run func(ctx context.Context, id int64) (*DeadLetterRecord, error)) *MockStore_GetDeadLetterByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetHumanDecision provides a mock function for the type MockStore
func (_mock *MockStore) GetHumanDecision(ctx context.Context, stepID int64) (*HumanDecisionRecord, error) {
	ret := _mock.Called(ctx, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetHumanDecision")
	}

	var r0 *HumanDecisionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*HumanDecisionRecord, error)); ok {
		return returnFunc(ctx, stepID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *HumanDecisionRecord); ok {
		r0 = returnFunc(ctx, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*HumanDecisionRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, stepID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetHumanDecision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHumanDecision'
type MockStore_GetHumanDecision_Call struct {
	*mock.Call
}

// GetHumanDecision is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
func (_e *MockStore_Expecter) GetHumanDecision(ctx interface{}, stepID interface{}) *MockStore_GetHumanDecision_Call {
	return &MockStore_GetHumanDecision_Call{Call: _e.mock.On("GetHumanDecision", ctx, stepID)}
}

func (_c *MockStore_GetHumanDecision_Call) Run(run func(ctx context.Context, stepID int64)) *MockStore_GetHumanDecision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetHumanDecision_Call) Return(humanDecisionRecord *HumanDecisionRecord, err error) *MockStore_GetHumanDecision_Call {
	_c.Call.Return(humanDecisionRecord, err)
	return _c
}

func (_c *MockStore_GetHumanDecision_Call) RunAndReturn(run func(ctx context.Context, stepID int64) (*HumanDecisionRecord, error)) *MockStore_GetHumanDecision_Call {
	_c.Call.Return(run)
	return _c
}

// GetHumanDecisionStepByInstanceID provides a mock function for the type MockStore
func (_mock *MockStore) GetHumanDecisionStepByInstanceID(ctx context.Context, instanceID int64) (*WorkflowStep, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetHumanDecisionStepByInstanceID")
	}

	var r0 *WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*WorkflowStep, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *WorkflowStep); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetHumanDecisionStepByInstanceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHumanDecisionStepByInstanceID'
type MockStore_GetHumanDecisionStepByInstanceID_Call struct {
	*mock.Call
}

// GetHumanDecisionStepByInstanceID is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetHumanDecisionStepByInstanceID(ctx interface{}, instanceID interface{}) *MockStore_GetHumanDecisionStepByInstanceID_Call {
	return &MockStore_GetHumanDecisionStepByInstanceID_Call{Call: _e.mock.On("GetHumanDecisionStepByInstanceID", ctx, instanceID)}
}

func (_c *MockStore_GetHumanDecisionStepByInstanceID_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetHumanDecisionStepByInstanceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetHumanDecisionStepByInstanceID_Call) Return(workflowStep *WorkflowStep, err error) *MockStore_GetHumanDecisionStepByInstanceID_Call {
	_c.Call.Return(workflowStep, err)
	return _c
}

func (_c *MockStore_GetHumanDecisionStepByInstanceID_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) (*WorkflowStep, error)) *MockStore_GetHumanDecisionStepByInstanceID_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstance provides a mock function for the type MockStore
func (_mock *MockStore) GetInstance(ctx context.Context, instanceID int64) (*WorkflowInstance, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetInstance")
	}

	var r0 *WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*WorkflowInstance, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *WorkflowInstance); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstance'
type MockStore_GetInstance_Call struct {
	*mock.Call
}

// GetInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetInstance(ctx interface{}, instanceID interface{}) *MockStore_GetInstance_Call {
	return &MockStore_GetInstance_Call{Call: _e.mock.On("GetInstance", ctx, instanceID)}
}

func (_c *MockStore_GetInstance_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetInstance_Call) Return(workflowInstance *WorkflowInstance, err error) *MockStore_GetInstance_Call {
	_c.Call.Return(workflowInstance, err)
	return _c
}

func (_c *MockStore_GetInstance_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) (*WorkflowInstance, error)) *MockStore_GetInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetJoinState provides a mock function for the type MockStore
func (_mock *MockStore) GetJoinState(ctx context.Context, instanceID int64, joinStepName string) (*JoinState, error) {
	ret := _mock.Called(ctx, instanceID, joinStepName)

	if len(ret) == 0 {
		panic("no return value specified for GetJoinState")
	}

	var r0 *JoinState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (*JoinState, error)); ok {
		return returnFunc(ctx, instanceID, joinStepName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) *JoinState); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JoinState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, instanceID, joinStepName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJoinState'
type MockStore_GetJoinState_Call struct {
	*mock.Call
}

// GetJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
func (_e *MockStore_Expecter) GetJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}) *MockStore_GetJoinState_Call {
	return &MockStore_GetJoinState_Call{Call: _e.mock.On("GetJoinState", ctx, instanceID, joinStepName)}
}

func (_c *MockStore_GetJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string)) *MockStore_GetJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_GetJoinState_Call) Return(joinState *JoinState, err error) *MockStore_GetJoinState_Call {
	_c.Call.Return(joinState, err)
	return _c
}

func (_c *MockStore_GetJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string) (*JoinState, error)) *MockStore_GetJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// GetStepByID provides a mock function for the type MockStore
func (_mock *MockStore) GetStepByID(ctx context.Context, stepID int64) (*WorkflowStep, error) {
	ret := _mock.Called(ctx, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetStepByID")
	}

	var r0 *WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*WorkflowStep, error)); ok {
		return returnFunc(ctx, stepID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *WorkflowStep); ok {
		r0 = returnFunc(ctx, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, stepID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetStepByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStepByID'
type MockStore_GetStepByID_Call struct {
	*mock.Call
}

// GetStepByID is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
func (_e *MockStore_Expecter) GetStepByID(ctx interface{}, stepID interface{}) *MockStore_GetStepByID_Call {
	return &MockStore_GetStepByID_Call{Call: _e.mock.On("GetStepByID", ctx, stepID)}
}

func (_c *MockStore_GetStepByID_Call) Run(run func(ctx context.Context, stepID int64)) *MockStore_GetStepByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetStepByID_Call) Return(workflowStep *WorkflowStep, err error) *MockStore_GetStepByID_Call {
	_c.Call.Return(workflowStep, err)
	return _c
}

func (_c *MockStore_GetStepByID_Call) RunAndReturn(run func(ctx context.Context, stepID int64) (*WorkflowStep, error)) *MockStore_GetStepByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetStepsByInstance provides a mock function for the type MockStore
func (_mock *MockStore) GetStepsByInstance(ctx context.Context, instanceID int64) ([]WorkflowStep, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetStepsByInstance")
	}

	var r0 []WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]WorkflowStep, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []WorkflowStep); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetStepsByInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStepsByInstance'
type MockStore_GetStepsByInstance_Call struct {
	*mock.Call
}

// GetStepsByInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetStepsByInstance(ctx interface{}, instanceID interface{}) *MockStore_GetStepsByInstance_Call {
	return &MockStore_GetStepsByInstance_Call{Call: _e.mock.On("GetStepsByInstance", ctx, instanceID)}
}

func (_c *MockStore_GetStepsByInstance_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetStepsByInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetStepsByInstance_Call) Return(workflowSteps []WorkflowStep, err error) *MockStore_GetStepsByInstance_Call {
	_c.Call.Return(workflowSteps, err)
	return _c
}

func (_c *MockStore_GetStepsByInstance_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) ([]WorkflowStep, error)) *MockStore_GetStepsByInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetSummaryStats provides a mock function for the type MockStore
func (_mock *MockStore) GetSummaryStats(ctx context.Context) (*SummaryStats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetSummaryStats")
	}

	var r0 *SummaryStats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*SummaryStats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *SummaryStats); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SummaryStats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetSummaryStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSummaryStats'
type MockStore_GetSummaryStats_Call struct {
	*mock.Call
}

// GetSummaryStats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetSummaryStats(ctx interface{}) *MockStore_GetSummaryStats_Call {
	return &MockStore_GetSummaryStats_Call{Call: _e.mock.On("GetSummaryStats", ctx)}
}

func (_c *MockStore_GetSummaryStats_Call) Run(run func(ctx context.Context)) *MockStore_GetSummaryStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetSummaryStats_Call) Return(summaryStats *SummaryStats, err error) *MockStore_GetSummaryStats_Call {
	_c.Call.Return(summaryStats, err)
	return _c
}

func (_c *MockStore_GetSummaryStats_Call) RunAndReturn(run func(ctx context.Context) (*SummaryStats, error)) *MockStore_GetSummaryStats_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowDefinition provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowDefinition(ctx context.Context, id string) (*WorkflowDefinition, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowDefinition")
	}

	var r0 *WorkflowDefinition
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*WorkflowDefinition, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *WorkflowDefinition); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorkflowDefinition)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowDefinition'
type MockStore_GetWorkflowDefinition_Call struct {
	*mock.Call
}

// GetWorkflowDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetWorkflowDefinition(ctx interface{}, id interface{}) *MockStore_GetWorkflowDefinition_Call {
	return &MockStore_GetWorkflowDefinition_Call{Call: _e.mock.On("GetWorkflowDefinition", ctx, id)}
}

func (_c *MockStore_GetWorkflowDefinition_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowDefinition_Call) Return(workflowDefinition *WorkflowDefinition, err error) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Return(workflowDefinition, err)
	return _c
}

func (_c *MockStore_GetWorkflowDefinition_Call) RunAndReturn(run func(ctx context.Context, id string) (*WorkflowDefinition, error)) *MockStore_GetWorkflowDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowDefinitions provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowDefinitions(ctx context.Context) ([]WorkflowDefinition, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowDefinitions")
	}

	var r0 []WorkflowDefinition
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]WorkflowDefinition, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []WorkflowDefinition); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowDefinition)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowDefinitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowDefinitions'
type MockStore_GetWorkflowDefinitions_Call struct {
	*mock.Call
}

// GetWorkflowDefinitions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetWorkflowDefinitions(ctx interface{}) *MockStore_GetWorkflowDefinitions_Call {
	return &MockStore_GetWorkflowDefinitions_Call{Call: _e.mock.On("GetWorkflowDefinitions", ctx)}
}

func (_c *MockStore_GetWorkflowDefinitions_Call) Run(run func(ctx context.Context)) *MockStore_GetWorkflowDefinitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowDefinitions_Call) Return(workflowDefinitions []WorkflowDefinition, err error) *MockStore_GetWorkflowDefinitions_Call {
	_c.Call.Return(workflowDefinitions, err)
	return _c
}

func (_c *MockStore_GetWorkflowDefinitions_Call) RunAndReturn(run func(ctx context.Context) ([]WorkflowDefinition, error)) *MockStore_GetWorkflowDefinitions_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowEvents provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowEvents(ctx context.Context, instanceID int64) ([]WorkflowEvent, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowEvents")
	}

	var r0 []WorkflowEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]WorkflowEvent, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []WorkflowEvent); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowEvents'
type MockStore_GetWorkflowEvents_Call struct {
	*mock.Call
}

// GetWorkflowEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetWorkflowEvents(ctx interface{}, instanceID interface{}) *MockStore_GetWorkflowEvents_Call {
	return &MockStore_GetWorkflowEvents_Call{Call: _e.mock.On("GetWorkflowEvents", ctx, instanceID)}
}

func (_c *MockStore_GetWorkflowEvents_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetWorkflowEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowEvents_Call) Return(workflowEvents []WorkflowEvent, err error) *MockStore_GetWorkflowEvents_Call {
	_c.Call.Return(workflowEvents, err)
	return _c
}

func (_c *MockStore_GetWorkflowEvents_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) ([]WorkflowEvent, error)) *MockStore_GetWorkflowEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowInstances provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowInstances(ctx context.Context, workflowID string) ([]WorkflowInstance, error) {
	ret := _mock.Called(ctx, workflowID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowInstances")
	}

	var r0 []WorkflowInstance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]WorkflowInstance, error)); ok {
		return returnFunc(ctx, workflowID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []WorkflowInstance); ok {
		r0 = returnFunc(ctx, workflowID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowInstance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, workflowID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowInstances'
type MockStore_GetWorkflowInstances_Call struct {
	*mock.Call
}

// GetWorkflowInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowID string
func (_e *MockStore_Expecter) GetWorkflowInstances(ctx interface{}, workflowID interface{}) *MockStore_GetWorkflowInstances_Call {
	return &MockStore_GetWorkflowInstances_Call{Call: _e.mock.On("GetWorkflowInstances", ctx, workflowID)}
}

func (_c *MockStore_GetWorkflowInstances_Call) Run(run func(ctx context.Context, workflowID string)) *MockStore_GetWorkflowInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowInstances_Call) Return(workflowInstances []WorkflowInstance, err error) *MockStore_GetWorkflowInstances_Call {
	_c.Call.Return(workflowInstances, err)
	return _c
}

func (_c *MockStore_GetWorkflowInstances_Call) RunAndReturn(run func(ctx context.Context, workflowID string) ([]WorkflowInstance, error)) *MockStore_GetWorkflowInstances_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowStats provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowStats(ctx context.Context) ([]WorkflowStats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowStats")
	}

	var r0 []WorkflowStats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]WorkflowStats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []WorkflowStats); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowStats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowStats'
type MockStore_GetWorkflowStats_Call struct {
	*mock.Call
}

// GetWorkflowStats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetWorkflowStats(ctx interface{}) *MockStore_GetWorkflowStats_Call {
	return &MockStore_GetWorkflowStats_Call{Call: _e.mock.On("GetWorkflowStats", ctx)}
}

func (_c *MockStore_GetWorkflowStats_Call) Run(run func(ctx context.Context)) *MockStore_GetWorkflowStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowStats_Call) Return(workflowStatss []WorkflowStats, err error) *MockStore_GetWorkflowStats_Call {
	_c.Call.Return(workflowStatss, err)
	return _c
}

func (_c *MockStore_GetWorkflowStats_Call) RunAndReturn(run func(ctx context.Context) ([]WorkflowStats, error)) *MockStore_GetWorkflowStats_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowSteps provides a mock function for the type MockStore
func (_mock *MockStore) GetWorkflowSteps(ctx context.Context, instanceID int64) ([]WorkflowStep, error) {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowSteps")
	}

	var r0 []WorkflowStep
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]WorkflowStep, error)); ok {
		return returnFunc(ctx, instanceID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []WorkflowStep); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WorkflowStep)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, instanceID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetWorkflowSteps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowSteps'
type MockStore_GetWorkflowSteps_Call struct {
	*mock.Call
}

// GetWorkflowSteps is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) GetWorkflowSteps(ctx interface{}, instanceID interface{}) *MockStore_GetWorkflowSteps_Call {
	return &MockStore_GetWorkflowSteps_Call{Call: _e.mock.On("GetWorkflowSteps", ctx, instanceID)}
}

func (_c *MockStore_GetWorkflowSteps_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_GetWorkflowSteps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetWorkflowSteps_Call) Return(workflowSteps []WorkflowStep, err error) *MockStore_GetWorkflowSteps_Call {
	_c.Call.Return(workflowSteps, err)
	return _c
}

func (_c *MockStore_GetWorkflowSteps_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) ([]WorkflowStep, error)) *MockStore_GetWorkflowSteps_Call {
	_c.Call.Return(run)
	return _c
}

// ListDeadLetters provides a mock function for the type MockStore
func (_mock *MockStore) ListDeadLetters(ctx context.Context, offset int, limit int) ([]DeadLetterRecord, int64, error) {
	ret := _mock.Called(ctx, offset, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListDeadLetters")
	}

	var r0 []DeadLetterRecord
	var r1 int64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]DeadLetterRecord, int64, error)); ok {
		return returnFunc(ctx, offset, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []DeadLetterRecord); ok {
		r0 = returnFunc(ctx, offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]DeadLetterRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int64); ok {
		r1 = returnFunc(ctx, offset, limit)
	} else {
		r1 = ret.Get(1).(int64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, offset, limit)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStore_ListDeadLetters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDeadLetters'
type MockStore_ListDeadLetters_Call struct {
	*mock.Call
}

// ListDeadLetters is a helper method to define mock.On call
//   - ctx context.Context
//   - offset int
//   - limit int
func (_e *MockStore_Expecter) ListDeadLetters(ctx interface{}, offset interface{}, limit interface{}) *MockStore_ListDeadLetters_Call {
	return &MockStore_ListDeadLetters_Call{Call: _e.mock.On("ListDeadLetters", ctx, offset, limit)}
}

func (_c *MockStore_ListDeadLetters_Call) Run(run func(ctx context.Context, offset int, limit int)) *MockStore_ListDeadLetters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_ListDeadLetters_Call) Return(deadLetterRecords []DeadLetterRecord, n int64, err error) *MockStore_ListDeadLetters_Call {
	_c.Call.Return(deadLetterRecords, n, err)
	return _c
}

func (_c *MockStore_ListDeadLetters_Call) RunAndReturn(run func(ctx context.Context, offset int, limit int) ([]DeadLetterRecord, int64, error)) *MockStore_ListDeadLetters_Call {
	_c.Call.Return(run)
	return _c
}

// LogEvent provides a mock function for the type MockStore
func (_mock *MockStore) LogEvent(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any) error {
	ret := _mock.Called(ctx, instanceID, stepID, eventType, payload)

	if len(ret) == 0 {
		panic("no return value specified for LogEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *int64, string, any) error); ok {
		r0 = returnFunc(ctx, instanceID, stepID, eventType, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_LogEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogEvent'
type MockStore_LogEvent_Call struct {
	*mock.Call
}

// LogEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - stepID *int64
//   - eventType string
//   - payload any
func (_e *MockStore_Expecter) LogEvent(ctx interface{}, instanceID interface{}, stepID interface{}, eventType interface{}, payload interface{}) *MockStore_LogEvent_Call {
	return &MockStore_LogEvent_Call{Call: _e.mock.On("LogEvent", ctx, instanceID, stepID, eventType, payload)}
}

func (_c *MockStore_LogEvent_Call) Run(run func(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any)) *MockStore_LogEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *int64
		if args[2] != nil {
			arg2 = args[2].(*int64)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 any
		if args[4] != nil {
			arg4 = args[4].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_LogEvent_Call) Return(err error) *MockStore_LogEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_LogEvent_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, stepID *int64, eventType string, payload any) error) *MockStore_LogEvent_Call {
	_c.Call.Return(run)
	return _c
}

// PauseActiveStepsAndClearQueue provides a mock function for the type MockStore
func (_mock *MockStore) PauseActiveStepsAndClearQueue(ctx context.Context, instanceID int64) error {
	ret := _mock.Called(ctx, instanceID)

	if len(ret) == 0 {
		panic("no return value specified for PauseActiveStepsAndClearQueue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, instanceID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_PauseActiveStepsAndClearQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseActiveStepsAndClearQueue'
type MockStore_PauseActiveStepsAndClearQueue_Call struct {
	*mock.Call
}

// PauseActiveStepsAndClearQueue is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
func (_e *MockStore_Expecter) PauseActiveStepsAndClearQueue(ctx interface{}, instanceID interface{}) *MockStore_PauseActiveStepsAndClearQueue_Call {
	return &MockStore_PauseActiveStepsAndClearQueue_Call{Call: _e.mock.On("PauseActiveStepsAndClearQueue", ctx, instanceID)}
}

func (_c *MockStore_PauseActiveStepsAndClearQueue_Call) Run(run func(ctx context.Context, instanceID int64)) *MockStore_PauseActiveStepsAndClearQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_PauseActiveStepsAndClearQueue_Call) Return(err error) *MockStore_PauseActiveStepsAndClearQueue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_PauseActiveStepsAndClearQueue_Call) RunAndReturn(run func(ctx context.Context, instanceID int64) error) *MockStore_PauseActiveStepsAndClearQueue_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseQueueItem provides a mock function for the type MockStore
func (_mock *MockStore) ReleaseQueueItem(ctx context.Context, queueID int64) error {
	ret := _mock.Called(ctx, queueID)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseQueueItem")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, queueID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ReleaseQueueItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseQueueItem'
type MockStore_ReleaseQueueItem_Call struct {
	*mock.Call
}

// ReleaseQueueItem is a helper method to define mock.On call
//   - ctx context.Context
//   - queueID int64
func (_e *MockStore_Expecter) ReleaseQueueItem(ctx interface{}, queueID interface{}) *MockStore_ReleaseQueueItem_Call {
	return &MockStore_ReleaseQueueItem_Call{Call: _e.mock.On("ReleaseQueueItem", ctx, queueID)}
}

func (_c *MockStore_ReleaseQueueItem_Call) Run(run func(ctx context.Context, queueID int64)) *MockStore_ReleaseQueueItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ReleaseQueueItem_Call) Return(err error) *MockStore_ReleaseQueueItem_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ReleaseQueueItem_Call) RunAndReturn(run func(ctx context.Context, queueID int64) error) *MockStore_ReleaseQueueItem_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFromQueue provides a mock function for the type MockStore
func (_mock *MockStore) RemoveFromQueue(ctx context.Context, queueID int64) error {
	ret := _mock.Called(ctx, queueID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFromQueue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, queueID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RemoveFromQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFromQueue'
type MockStore_RemoveFromQueue_Call struct {
	*mock.Call
}

// RemoveFromQueue is a helper method to define mock.On call
//   - ctx context.Context
//   - queueID int64
func (_e *MockStore_Expecter) RemoveFromQueue(ctx interface{}, queueID interface{}) *MockStore_RemoveFromQueue_Call {
	return &MockStore_RemoveFromQueue_Call{Call: _e.mock.On("RemoveFromQueue", ctx, queueID)}
}

func (_c *MockStore_RemoveFromQueue_Call) Run(run func(ctx context.Context, queueID int64)) *MockStore_RemoveFromQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_RemoveFromQueue_Call) Return(err error) *MockStore_RemoveFromQueue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RemoveFromQueue_Call) RunAndReturn(run func(ctx context.Context, queueID int64) error) *MockStore_RemoveFromQueue_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceInJoinWaitFor provides a mock function for the type MockStore
func (_mock *MockStore) ReplaceInJoinWaitFor(ctx context.Context, instanceID int64, joinStepName string, virtualStep string, realStep string) error {
	ret := _mock.Called(ctx, instanceID, joinStepName, virtualStep, realStep)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceInJoinWaitFor")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string) error); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, virtualStep, realStep)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_ReplaceInJoinWaitFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceInJoinWaitFor'
type MockStore_ReplaceInJoinWaitFor_Call struct {
	*mock.Call
}

// ReplaceInJoinWaitFor is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - virtualStep string
//   - realStep string
func (_e *MockStore_Expecter) ReplaceInJoinWaitFor(ctx interface{}, instanceID interface{}, joinStepName interface{}, virtualStep interface{}, realStep interface{}) *MockStore_ReplaceInJoinWaitFor_Call {
	return &MockStore_ReplaceInJoinWaitFor_Call{Call: _e.mock.On("ReplaceInJoinWaitFor", ctx, instanceID, joinStepName, virtualStep, realStep)}
}

func (_c *MockStore_ReplaceInJoinWaitFor_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, virtualStep string, realStep string)) *MockStore_ReplaceInJoinWaitFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_ReplaceInJoinWaitFor_Call) Return(err error) *MockStore_ReplaceInJoinWaitFor_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_ReplaceInJoinWaitFor_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, virtualStep string, realStep string) error) *MockStore_ReplaceInJoinWaitFor_Call {
	_c.Call.Return(run)
	return _c
}

// RequeueDeadLetter provides a mock function for the type MockStore
func (_mock *MockStore) RequeueDeadLetter(ctx context.Context, dlqID int64, newInput *json.RawMessage) error {
	ret := _mock.Called(ctx, dlqID, newInput)

	if len(ret) == 0 {
		panic("no return value specified for RequeueDeadLetter")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *json.RawMessage) error); ok {
		r0 = returnFunc(ctx, dlqID, newInput)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RequeueDeadLetter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequeueDeadLetter'
type MockStore_RequeueDeadLetter_Call struct {
	*mock.Call
}

// RequeueDeadLetter is a helper method to define mock.On call
//   - ctx context.Context
//   - dlqID int64
//   - newInput *json.RawMessage
func (_e *MockStore_Expecter) RequeueDeadLetter(ctx interface{}, dlqID interface{}, newInput interface{}) *MockStore_RequeueDeadLetter_Call {
	return &MockStore_RequeueDeadLetter_Call{Call: _e.mock.On("RequeueDeadLetter", ctx, dlqID, newInput)}
}

func (_c *MockStore_RequeueDeadLetter_Call) Run(run func(ctx context.Context, dlqID int64, newInput *json.RawMessage)) *MockStore_RequeueDeadLetter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *json.RawMessage
		if args[2] != nil {
			arg2 = args[2].(*json.RawMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_RequeueDeadLetter_Call) Return(err error) *MockStore_RequeueDeadLetter_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RequeueDeadLetter_Call) RunAndReturn(run func(ctx context.Context, dlqID int64, newInput *json.RawMessage) error) *MockStore_RequeueDeadLetter_Call {
	_c.Call.Return(run)
	return _c
}

// RescheduleAndReleaseQueueItem provides a mock function for the type MockStore
func (_mock *MockStore) RescheduleAndReleaseQueueItem(ctx context.Context, queueID int64, delay time.Duration) error {
	ret := _mock.Called(ctx, queueID, delay)

	if len(ret) == 0 {
		panic("no return value specified for RescheduleAndReleaseQueueItem")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, time.Duration) error); ok {
		r0 = returnFunc(ctx, queueID, delay)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RescheduleAndReleaseQueueItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RescheduleAndReleaseQueueItem'
type MockStore_RescheduleAndReleaseQueueItem_Call struct {
	*mock.Call
}

// RescheduleAndReleaseQueueItem is a helper method to define mock.On call
//   - ctx context.Context
//   - queueID int64
//   - delay time.Duration
func (_e *MockStore_Expecter) RescheduleAndReleaseQueueItem(ctx interface{}, queueID interface{}, delay interface{}) *MockStore_RescheduleAndReleaseQueueItem_Call {
	return &MockStore_RescheduleAndReleaseQueueItem_Call{Call: _e.mock.On("RescheduleAndReleaseQueueItem", ctx, queueID, delay)}
}

func (_c *MockStore_RescheduleAndReleaseQueueItem_Call) Run(run func(ctx context.Context, queueID int64, delay time.Duration)) *MockStore_RescheduleAndReleaseQueueItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_RescheduleAndReleaseQueueItem_Call) Return(err error) *MockStore_RescheduleAndReleaseQueueItem_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RescheduleAndReleaseQueueItem_Call) RunAndReturn(run func(ctx context.Context, queueID int64, delay time.Duration) error) *MockStore_RescheduleAndReleaseQueueItem_Call {
	_c.Call.Return(run)
	return _c
}

// SaveWorkflowDefinition provides a mock function for the type MockStore
func (_mock *MockStore) SaveWorkflowDefinition(ctx context.Context, def *WorkflowDefinition) error {
	ret := _mock.Called(ctx, def)

	if len(ret) == 0 {
		panic("no return value specified for SaveWorkflowDefinition")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *WorkflowDefinition) error); ok {
		r0 = returnFunc(ctx, def)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_SaveWorkflowDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveWorkflowDefinition'
type MockStore_SaveWorkflowDefinition_Call struct {
	*mock.Call
}

// SaveWorkflowDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - def *WorkflowDefinition
func (_e *MockStore_Expecter) SaveWorkflowDefinition(ctx interface{}, def interface{}) *MockStore_SaveWorkflowDefinition_Call {
	return &MockStore_SaveWorkflowDefinition_Call{Call: _e.mock.On("SaveWorkflowDefinition", ctx, def)}
}

func (_c *MockStore_SaveWorkflowDefinition_Call) Run(run func(ctx context.Context, def *WorkflowDefinition)) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *WorkflowDefinition
		if args[1] != nil {
			arg1 = args[1].(*WorkflowDefinition)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_SaveWorkflowDefinition_Call) Return(err error) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_SaveWorkflowDefinition_Call) RunAndReturn(run func(ctx context.Context, def *WorkflowDefinition) error) *MockStore_SaveWorkflowDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// SetAgingEnabled provides a mock function for the type MockStore
func (_mock *MockStore) SetAgingEnabled(enabled bool) {
	_mock.Called(enabled)
	return
}

// MockStore_SetAgingEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAgingEnabled'
type MockStore_SetAgingEnabled_Call struct {
	*mock.Call
}

// SetAgingEnabled is a helper method to define mock.On call
//   - enabled bool
func (_e *MockStore_Expecter) SetAgingEnabled(enabled interface{}) *MockStore_SetAgingEnabled_Call {
	return &MockStore_SetAgingEnabled_Call{Call: _e.mock.On("SetAgingEnabled", enabled)}
}

func (_c *MockStore_SetAgingEnabled_Call) Run(run func(enabled bool)) *MockStore_SetAgingEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 bool
		if args[0] != nil {
			arg0 = args[0].(bool)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_SetAgingEnabled_Call) Return() *MockStore_SetAgingEnabled_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStore_SetAgingEnabled_Call) RunAndReturn(run func(enabled bool)) *MockStore_SetAgingEnabled_Call {
	_c.Run(run)
	return _c
}

// SetAgingRate provides a mock function for the type MockStore
func (_mock *MockStore) SetAgingRate(rate float64) {
	_mock.Called(rate)
	return
}

// MockStore_SetAgingRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAgingRate'
type MockStore_SetAgingRate_Call struct {
	*mock.Call
}

// SetAgingRate is a helper method to define mock.On call
//   - rate float64
func (_e *MockStore_Expecter) SetAgingRate(rate interface{}) *MockStore_SetAgingRate_Call {
	return &MockStore_SetAgingRate_Call{Call: _e.mock.On("SetAgingRate", rate)}
}

func (_c *MockStore_SetAgingRate_Call) Run(run func(rate float64)) *MockStore_SetAgingRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 float64
		if args[0] != nil {
			arg0 = args[0].(float64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_SetAgingRate_Call) Return() *MockStore_SetAgingRate_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStore_SetAgingRate_Call) RunAndReturn(run func(rate float64)) *MockStore_SetAgingRate_Call {
	_c.Run(run)
	return _c
}

// UpdateInstanceStatus provides a mock function for the type MockStore
func (_mock *MockStore) UpdateInstanceStatus(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string) error {
	ret := _mock.Called(ctx, instanceID, status, output, errMsg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInstanceStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, WorkflowStatus, json.RawMessage, *string) error); ok {
		r0 = returnFunc(ctx, instanceID, status, output, errMsg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateInstanceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInstanceStatus'
type MockStore_UpdateInstanceStatus_Call struct {
	*mock.Call
}

// UpdateInstanceStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - status WorkflowStatus
//   - output json.RawMessage
//   - errMsg *string
func (_e *MockStore_Expecter) UpdateInstanceStatus(ctx interface{}, instanceID interface{}, status interface{}, output interface{}, errMsg interface{}) *MockStore_UpdateInstanceStatus_Call {
	return &MockStore_UpdateInstanceStatus_Call{Call: _e.mock.On("UpdateInstanceStatus", ctx, instanceID, status, output, errMsg)}
}

func (_c *MockStore_UpdateInstanceStatus_Call) Run(run func(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string)) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 WorkflowStatus
		if args[2] != nil {
			arg2 = args[2].(WorkflowStatus)
		}
		var arg3 json.RawMessage
		if args[3] != nil {
			arg3 = args[3].(json.RawMessage)
		}
		var arg4 *string
		if args[4] != nil {
			arg4 = args[4].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateInstanceStatus_Call) Return(err error) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateInstanceStatus_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, status WorkflowStatus, output json.RawMessage, errMsg *string) error) *MockStore_UpdateInstanceStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJoinState provides a mock function for the type MockStore
func (_mock *MockStore) UpdateJoinState(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool) (bool, error) {
	ret := _mock.Called(ctx, instanceID, joinStepName, completedStep, success)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJoinState")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, bool) (bool, error)); ok {
		return returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, bool) bool); ok {
		r0 = returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, bool) error); ok {
		r1 = returnFunc(ctx, instanceID, joinStepName, completedStep, success)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_UpdateJoinState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJoinState'
type MockStore_UpdateJoinState_Call struct {
	*mock.Call
}

// UpdateJoinState is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceID int64
//   - joinStepName string
//   - completedStep string
//   - success bool
func (_e *MockStore_Expecter) UpdateJoinState(ctx interface{}, instanceID interface{}, joinStepName interface{}, completedStep interface{}, success interface{}) *MockStore_UpdateJoinState_Call {
	return &MockStore_UpdateJoinState_Call{Call: _e.mock.On("UpdateJoinState", ctx, instanceID, joinStepName, completedStep, success)}
}

func (_c *MockStore_UpdateJoinState_Call) Run(run func(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool)) *MockStore_UpdateJoinState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateJoinState_Call) Return(b bool, err error) *MockStore_UpdateJoinState_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockStore_UpdateJoinState_Call) RunAndReturn(run func(ctx context.Context, instanceID int64, joinStepName string, completedStep string, success bool) (bool, error)) *MockStore_UpdateJoinState_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStep provides a mock function for the type MockStore
func (_mock *MockStore) UpdateStep(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string) error {
	ret := _mock.Called(ctx, stepID, status, output, errMsg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, StepStatus, json.RawMessage, *string) error); ok {
		r0 = returnFunc(ctx, stepID, status, output, errMsg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateStep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStep'
type MockStore_UpdateStep_Call struct {
	*mock.Call
}

// UpdateStep is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - status StepStatus
//   - output json.RawMessage
//   - errMsg *string
func (_e *MockStore_Expecter) UpdateStep(ctx interface{}, stepID interface{}, status interface{}, output interface{}, errMsg interface{}) *MockStore_UpdateStep_Call {
	return &MockStore_UpdateStep_Call{Call: _e.mock.On("UpdateStep", ctx, stepID, status, output, errMsg)}
}

func (_c *MockStore_UpdateStep_Call) Run(run func(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string)) *MockStore_UpdateStep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 StepStatus
		if args[2] != nil {
			arg2 = args[2].(StepStatus)
		}
		var arg3 json.RawMessage
		if args[3] != nil {
			arg3 = args[3].(json.RawMessage)
		}
		var arg4 *string
		if args[4] != nil {
			arg4 = args[4].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_UpdateStep_Call) Return(err error) *MockStore_UpdateStep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateStep_Call) RunAndReturn(run func(ctx context.Context, stepID int64, status StepStatus, output json.RawMessage, errMsg *string) error) *MockStore_UpdateStep_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStepCompensationRetry provides a mock function for the type MockStore
func (_mock *MockStore) UpdateStepCompensationRetry(ctx context.Context, stepID int64, retryCount int, status StepStatus) error {
	ret := _mock.Called(ctx, stepID, retryCount, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStepCompensationRetry")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int, StepStatus) error); ok {
		r0 = returnFunc(ctx, stepID, retryCount, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateStepCompensationRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStepCompensationRetry'
type MockStore_UpdateStepCompensationRetry_Call struct {
	*mock.Call
}

// UpdateStepCompensationRetry is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - retryCount int
//   - status StepStatus
func (_e *MockStore_Expecter) UpdateStepCompensationRetry(ctx interface{}, stepID interface{}, retryCount interface{}, status interface{}) *MockStore_UpdateStepCompensationRetry_Call {
	return &MockStore_UpdateStepCompensationRetry_Call{Call: _e.mock.On("UpdateStepCompensationRetry", ctx, stepID, retryCount, status)}
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) Run(run func(ctx context.Context, stepID int64, retryCount int, status StepStatus)) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 StepStatus
		if args[3] != nil {
			arg3 = args[3].(StepStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) Return(err error) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateStepCompensationRetry_Call) RunAndReturn(run func(ctx context.Context, stepID int64, retryCount int, status StepStatus) error) *MockStore_UpdateStepCompensationRetry_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStepStatus provides a mock function for the type MockStore
func (_mock *MockStore) UpdateStepStatus(ctx context.Context, stepID int64, status StepStatus) error {
	ret := _mock.Called(ctx, stepID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStepStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, StepStatus) error); ok {
		r0 = returnFunc(ctx, stepID, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateStepStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStepStatus'
type MockStore_UpdateStepStatus_Call struct {
	*mock.Call
}

// UpdateStepStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - stepID int64
//   - status StepStatus
func (_e *MockStore_Expecter) UpdateStepStatus(ctx interface{}, stepID interface{}, status interface{}) *MockStore_UpdateStepStatus_Call {
	return &MockStore_UpdateStepStatus_Call{Call: _e.mock.On("UpdateStepStatus", ctx, stepID, status)}
}

func (_c *MockStore_UpdateStepStatus_Call) Run(run func(ctx context.Context, stepID int64, status StepStatus)) *MockStore_UpdateStepStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 StepStatus
		if args[2] != nil {
			arg2 = args[2].(StepStatus)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_UpdateStepStatus_Call) Return(err error) *MockStore_UpdateStepStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateStepStatus_Call) RunAndReturn(run func(ctx context.Context, stepID int64, status StepStatus) error) *MockStore_UpdateStepStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTx creates a new instance of MockTx. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTx(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTx {
	mock := &MockTx{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTx is an autogenerated mock type for the Tx type
type MockTx struct {
	mock.Mock
}

type MockTx_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTx) EXPECT() *MockTx_Expecter {
	return &MockTx_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockTx
func (_mock *MockTx) Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 pgconn.CommandTag
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (pgconn.CommandTag, error)); ok {
		return returnFunc(ctx, sql, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgconn.CommandTag); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		r0 = ret.Get(0).(pgconn.CommandTag)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, sql, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTx_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockTx_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) Exec(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_Exec_Call {
	return &MockTx_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_Exec_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_Exec_Call) Return(commandTag pgconn.CommandTag, err error) *MockTx_Exec_Call {
	_c.Call.Return(commandTag, err)
	return _c
}

func (_c *MockTx_Exec_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error)) *MockTx_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function for the type MockTx
func (_mock *MockTx) Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 pgx.Rows
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (pgx.Rows, error)); ok {
		return returnFunc(ctx, sql, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgx.Rows); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Rows)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, sql, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTx_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type MockTx_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) Query(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_Query_Call {
	return &MockTx_Query_Call{Call: _e.mock.On("Query",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_Query_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_Query_Call) Return(rows pgx.Rows, err error) *MockTx_Query_Call {
	_c.Call.Return(rows, err)
	return _c
}

func (_c *MockTx_Query_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) (pgx.Rows, error)) *MockTx_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRow provides a mock function for the type MockTx
func (_mock *MockTx) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, sql, args)
	} else {
		tmpRet = _mock.Called(ctx, sql)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for QueryRow")
	}

	var r0 pgx.Row
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) pgx.Row); ok {
		r0 = returnFunc(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Row)
		}
	}
	return r0
}

// MockTx_QueryRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRow'
type MockTx_QueryRow_Call struct {
	*mock.Call
}

// QueryRow is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...any
func (_e *MockTx_Expecter) QueryRow(ctx interface{}, sql interface{}, args ...interface{}) *MockTx_QueryRow_Call {
	return &MockTx_QueryRow_Call{Call: _e.mock.On("QueryRow",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *MockTx_QueryRow_Call) Run(run func(ctx context.Context, sql string, args ...any)) *MockTx_QueryRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTx_QueryRow_Call) Return(row pgx.Row) *MockTx_QueryRow_Call {
	_c.Call.Return(row)
	return _c
}

func (_c *MockTx_QueryRow_Call) RunAndReturn(run func(ctx context.Context, sql string, args ...any) pgx.Row) *MockTx_QueryRow_Call {
	_c.Call.Return(run)
	return _c
}

// SendBatch provides a mock function for the type MockTx
func (_mock *MockTx) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for SendBatch")
	}

	var r0 pgx.BatchResults
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pgx.Batch) pgx.BatchResults); ok {
		r0 = returnFunc(ctx, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.BatchResults)
		}
	}
	return r0
}

// MockTx_SendBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendBatch'
type MockTx_SendBatch_Call struct {
	*mock.Call
}

// SendBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - b *pgx.Batch
func (_e *MockTx_Expecter) SendBatch(ctx interface{}, b interface{}) *MockTx_SendBatch_Call {
	return &MockTx_SendBatch_Call{Call: _e.mock.On("SendBatch", ctx, b)}
}

func (_c *MockTx_SendBatch_Call) Run(run func(ctx context.Context, b *pgx.Batch)) *MockTx_SendBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pgx.Batch
		if args[1] != nil {
			arg1 = args[1].(*pgx.Batch)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTx_SendBatch_Call) Return(batchResults pgx.BatchResults) *MockTx_SendBatch_Call {
	_c.Call.Return(batchResults)
	return _c
}

func (_c *MockTx_SendBatch_Call) RunAndReturn(run func(ctx context.Context, b *pgx.Batch) pgx.BatchResults) *MockTx_SendBatch_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTxManager creates a new instance of MockTxManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTxManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTxManager {
	mock := &MockTxManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTxManager is an autogenerated mock type for the TxManager type
type MockTxManager struct {
	mock.Mock
}

type MockTxManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTxManager) EXPECT() *MockTxManager_Expecter {
	return &MockTxManager_Expecter{mock: &_m.Mock}
}

// ReadCommitted provides a mock function for the type MockTxManager
func (_mock *MockTxManager) ReadCommitted(ctx context.Context, fn func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for ReadCommitted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTxManager_ReadCommitted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadCommitted'
type MockTxManager_ReadCommitted_Call struct {
	*mock.Call
}

// ReadCommitted is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context) error
func (_e *MockTxManager_Expecter) ReadCommitted(ctx interface{}, fn interface{}) *MockTxManager_ReadCommitted_Call {
	return &MockTxManager_ReadCommitted_Call{Call: _e.mock.On("ReadCommitted", ctx, fn)}
}

func (_c *MockTxManager_ReadCommitted_Call) Run(run func(ctx context.Context, fn func(ctx context.Context) error)) *MockTxManager_ReadCommitted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTxManager_ReadCommitted_Call) Return(err error) *MockTxManager_ReadCommitted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTxManager_ReadCommitted_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context) error) error) *MockTxManager_ReadCommitted_Call {
	_c.Call.Return(run)
	return _c
}

// RepeatableRead provides a mock function for the type MockTxManager
func (_mock *MockTxManager) RepeatableRead(ctx context.Context, fn func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for RepeatableRead")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTxManager_RepeatableRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepeatableRead'
type MockTxManager_RepeatableRead_Call struct {
	*mock.Call
}

// RepeatableRead is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context) error
func (_e *MockTxManager_Expecter) RepeatableRead(ctx interface{}, fn interface{}) *MockTxManager_RepeatableRead_Call {
	return &MockTxManager_RepeatableRead_Call{Call: _e.mock.On("RepeatableRead", ctx, fn)}
}

func (_c *MockTxManager_RepeatableRead_Call) Run(run func(ctx context.Context, fn func(ctx context.Context) error)) *MockTxManager_RepeatableRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTxManager_RepeatableRead_Call) Return(err error) *MockTxManager_RepeatableRead_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTxManager_RepeatableRead_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context) error) error) *MockTxManager_RepeatableRead_Call {
	_c.Call.Return(run)
	return _c
}
