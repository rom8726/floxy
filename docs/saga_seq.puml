@startuml Saga Compensation Sequence

title Saga Compensation Flow in Floxy

participant "Engine" as E
participant "Store" as S
participant "StepHandler" as H
participant "CompensationHandler" as CH
participant "Database" as DB

== Normal Step Execution ==
E -> S: ExecuteNext()
S -> DB: DequeueStep()
DB --> S: QueueItem
S --> E: QueueItem

E -> S: GetInstance()
S --> E: WorkflowInstance

E -> S: GetStepsByInstance()
S --> E: WorkflowStep[]

E -> S: UpdateStep(status=running)
S -> DB: UPDATE workflow_steps SET status='running'
DB --> S: OK
S --> E: OK

E -> H: Execute(stepCtx, input)
H --> E: output/error

alt Step Success
    E -> S: UpdateStep(status=completed, output)
    S -> DB: UPDATE workflow_steps SET status='completed'
    DB --> S: OK
    S --> E: OK
else Step Failure
    E -> S: UpdateStep(status=failed, error)
    S -> DB: UPDATE workflow_steps SET status='failed'
    DB --> S: OK
    S --> E: OK

    == Rollback Process ==
    E -> E: rollbackToSavePointOrRoot()
    E -> E: rollbackStepChain()

    loop For each step in rollback chain
        E -> S: GetWorkflowDefinition()
        S --> E: WorkflowDefinition

        E -> E: rollbackStep()

        alt Step is Condition in Parallel Flow
            E -> E: determineExecutedBranch(conditionStep, stepDef, stepMap)
            note right: Check which branch (Next/Else) was actually executed
            
            alt Next branch was executed
                loop For each step in Next branch
                    E -> E: rollbackStepChain(nextStep, ...)
                end
            else Else branch was executed
                E -> E: rollbackStepChain(elseStep, ...)
            end
        else Regular step
            alt Has OnFailure handler
                E -> S: UpdateStepCompensationRetry(\nretryCount++, status=compensation)
                S -> DB: UPDATE workflow_steps SET\ncompensation_retry_count++, status='compensation'
                DB --> S: OK
                S --> E: OK

                E -> S: EnqueueStep(stepID)
                S -> DB: INSERT INTO workflow_queue
                DB --> S: OK
                S --> E: OK

                E -> S: LogEvent(compensation_started)
                S -> DB: INSERT INTO workflow_events
                DB --> S: OK
                S --> E: OK
            else No OnFailure handler
                E -> S: UpdateStep(status=rolled_back)
                S -> DB: UPDATE workflow_steps SET status='rolled_back'
                DB --> S: OK
                S --> E: OK
            end
        end
    end

    E -> S: UpdateInstanceStatus(status=failed)
    S -> DB: UPDATE workflow_instances SET status='failed'
    DB --> S: OK
    S --> E: OK
end

== Compensation Execution ==
E -> S: ExecuteNext()
S -> DB: DequeueStep()
DB --> S: QueueItem (step with status=compensation)
S --> E: QueueItem

E -> S: GetStepsByInstance()
S --> E: WorkflowStep[] (with compensation status)

E -> E: executeCompensationStep()

E -> S: GetWorkflowDefinition()
S --> E: WorkflowDefinition

E -> S: GetStepsByInstance()
S --> E: WorkflowStep[]

E -> CH: Execute(stepCtx, input)
note right: stepCtx.retryCount = step.CompensationRetryCount

alt Compensation Success
    E -> S: UpdateStep(status=rolled_back)
    S -> DB: UPDATE workflow_steps SET status='rolled_back'
    DB --> S: OK
    S --> E: OK

    E -> S: LogEvent(compensation_success)
    S -> DB: INSERT INTO workflow_events
    DB --> S: OK
    S --> E: OK

else Compensation Failure
    alt Can Retry (CompensationRetryCount < MaxRetries)
        E -> S: UpdateStepCompensationRetry(\nretryCount++, status=compensation)
        S -> DB: UPDATE workflow_steps SET\ncompensation_retry_count++, status='compensation'
        DB --> S: OK
        S --> E: OK

        E -> S: EnqueueStep(stepID)
        S -> DB: INSERT INTO workflow_queue
        DB --> S: OK
        S --> E: OK

        E -> S: LogEvent(compensation_retry)
        S -> DB: INSERT INTO workflow_events
        DB --> S: OK
        S --> E: OK

    else Max Retries Exceeded
        E -> S: UpdateStep(status=failed, error)
        S -> DB: UPDATE workflow_steps SET status='failed'
        DB --> S: OK
        S --> E: OK

        E -> S: LogEvent(compensation_max_retries_exceeded)
        S -> DB: INSERT INTO workflow_events
        DB --> S: OK
        S --> E: OK
    end
end

== Condition Step Execution ==
note over E: Special handling for condition steps

E -> E: executeCondition(stepCtx, stepDef)
E -> E: evaluateCondition(expr, stepCtx)
note right: Uses Go template with functions:\neq, ne, gt, lt, ge, le

alt Condition is True
    E -> E: enqueueNextSteps(stepDef.Next)
    note right: Execute Next branch steps
else Condition is False
    E -> E: enqueueNextSteps(stepDef.Else)
    note right: Execute Else branch steps
end

== Parallel Flow Rollback with Conditions ==
note over E: When rolling back parallel flows with condition steps

E -> E: rollbackStepChain(parallelStep, ...)

loop For each parallel branch
    E -> E: Check if branch contains condition steps
    
    alt Branch has condition step
        E -> E: determineExecutedBranch(conditionStep, stepDef, stepMap)
        note right: Check stepMap to see which branch was executed
        
        alt Next branch was executed
            E -> E: rollbackStepChain(nextStep, ...)
            note right: Rollback only Next branch steps
        else Else branch was executed
            E -> E: rollbackStepChain(elseStep, ...)
            note right: Rollback only Else branch steps
        end
    else Branch has no condition step
        E -> E: rollbackStepChain(regularStep, ...)
        note right: Standard rollback for regular steps
    end
end

@enduml
